# Redis知识梳理

## 一、数据类型

1. 字符串（String）
2. 列表（List）：按照插入顺序排序的字符串列表。访问两端元素的时间复杂度为O(1)，中间元素的为O(N)。
3. 哈希表（Hash）：字符串键和字符串值之间的映射。增删改查的时间复杂度为O(1)。
4. 集合（Set）：无序的唯一字符串合集。增删改查的时间复杂度为O(1)。
5. 有序集合（SortedSet）：有序的唯一字符串合集，合集中的所有字符串根据与其相关联的评分从低到高排列。增删改查的时间复杂度为O(logN)。

## 二、数据结构与对象

1. 简单动态字符串（simple dynamic string，SDS）
   1. 结构：简单动态字符串中包含一个字节数组，用于保存字符串；一个len属性，用于记录字节数组所保存字符串的长度；一个free属性，用于记录字节数组中未使用字节的数量。
      ![SDS示例](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220626172441.png)
   2. 优势：
      - 常数复杂度获取字符串长度：直接返回len属性即可。
      - 杜绝缓冲区溢出：在修改字符串前，先检查len属性和free属性，空间不足时进行内存重分配。
      - 减少修改字符串带来的内存重分配次数：
        - 空间预分配：扩展简单动态字符串时，会额外分配空间。
        - 惰性空间释放：缩短简单动态字符串时，并不立即内存重分配，而是将缩短的字节数量增加到free属性中。
      - 二进制安全：简单动态字符串的API以处理二进制的方式来处理字节数组中的数据，例如：使用len属性而不是空字符来判断字符串是否结束。
      - 兼容部分C字符串函数：简单动态字符串遵循了C字符串以空字符结尾的惯例，可以在需要时重用部分C字符串函数。
2. 链表
   特性：双端；无环；带表头指针和表尾指针；带链表长度计数器；多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。
   ![由list结构和listNode结构组成的链表](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220626172521.png)
3. 字典
   1. 结构
      - 字典中包含两个哈希表，一般情况下只使用第一个哈希表，第二个哈希表只在rehash时使用；一个rehashidx属性，记录rehash目前的进度，不在rehash时它的值为-1；一簇用于操作特定类型键值对的函数和需要传给那些类型特定函数的可选参数。
      - 哈希表中包含一个哈希表节点数组；一个size属性，记录哈希表大小；一个sizemask属性，等于size-1，这个属性和哈希值一起用于计算键的索引值；一个used属性，记录哈希表已有节点的数量。
      - 哈希表节点中保存着一个键值对，和指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突的问题。

      ![普通状态下的字典](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220626172647.png)
   2. 哈希算法
      1. 使用字典设置的哈希函数，计算键的哈希值；
      2. 将键的哈希值与哈希表的sizemask属性做与&操作，计算键的索引值。因为sizemask=size-1，所以与&的结果即索引值的范围为0~size-1；
      3. 当多个键的索引值相同时，即这些键发生了冲突，Redis的哈希表使用链地址法解决键冲突。
   3. 渐进式rehash
      1. 根据要执行的操作和旧哈希表的used属性，为新哈希表分配空间，让字典同时持有两个哈希表；
      2. 将字典的rehashidx属性设置为0，表示开始rehash；
      3. 在rehash期间，每次对字典增删改查时，除了执行指定的操作，还会将旧哈希表在rehashidx索引上的所有键值对rehash到新哈希表上，然后将rehashidx属性的值加1；
      4. 随着字典操作的不断执行，最终旧哈希表的所有键值对都会被rehash到新哈希表上，最后用新哈希表替换旧哈希表，释放旧哈希表，将rehashidx属性设为-1，至此rehash操作全部完成。
4. 跳跃表（skiplist）
   1. 概念：跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且跳跃表的实现比平衡树更简单。
   2. 实现：
      - 跳跃表中包含表头指针和表尾指针，其中表头节点是不包含数据的哨兵节点，表尾节点是包含数据的数据节点；一个length属性，记录表中节点的数量；一个level属性，记录跳跃表内除表头节点外层数最大的节点的层数。
      - 跳跃表节点中包含一个层数组，数组的大小是创建节点时根据幂次定律（power law）随机生成的一个1~32之间的值，也即节点的层数；层元素在数组中的位置代表该层的层高，每层包含一个前进指针和一个跨度，前进指针指向表尾方向的下一个具有如此层高的节点，跨度记录前进指针所指向节点和当前节点的距离；一个后退指针，指向位于当前节点的前一个节点；还有一个分值和一个成员对象。

      ![一个跳跃表](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220626172804.png)
5. 整数集合
   1. 结构：一个encoding属性，表示编码方式；一个length属性，记录集合包含的元素数量；一个保存元素的整数数组，这个数组以有序、无重复的方式保存集合元素。
      ![一个包含五个int16_t类型整数值的整数集合](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220626172921.png)
   2. 升级：当要将一个新元素添加到整数集合里面，且新元素的类型比当前类型更长时，会先扩展整数集合底层数组的空间大小，再将底层数组现有的所有元素都转换成与新元素相同的类型，并放置到正确的位置上，最后将新元素添加到底层数组里面。
      升级的好处：提升整数集合的灵活性；尽可能地节约内存。
      整数集合不支持降级操作。
6. 压缩列表
   1. 构成：
      - 压缩列表
         ![压缩列表的各个组成部分](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220626171653.png)
         |  属性  |  类型  | 长度 |              用途              |
         |:------:|:-----:|:----:|:------------------------------|
         |zlbytes|uint32_t| 4字节 |记录整个压缩列表占用的内存字节数|
         |zltail|uint32_t| 4字节 |记录压缩列表表尾节点距离压缩列表的起始地址有多少字节|
         |zllen|uint16_t| 2字节 |记录了压缩列表包含的节点数量|
         |entryX|列表节点| 不定 |压缩列表包含的各个节点，节点的长度由节点保存的内容决定。|
         |zlend|uint8_t| 1字节 |特殊值0xFF（十进制255），用于标记压缩列表的末端。|
      - 压缩列表节点
         ![压缩列表节点的各个组成部分](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220626172338.png)
7. 对象
   1. 概念：Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是：type属性，记录对象的类型；encoding属性，记录对象所使用的编码；ptr指针，指向对象的底层实现数据结构。
      |  类型  |      编码      |          对象          |
      |:------:|:--------------:|:---------------------|
      |REDIS_STRING|REDIS_ENCODING_INT|使用整数值实现的字符串对象。|
      |REDIS_STRING|REDIS_ENCODING_EMBSTR|使用embstr编码的简单动态字符串实现的字符串对象。|
      |REDIS_STRING|REDIS_ENCODING_RAW|使用简单动态字符串实现的字符串对象。|
      |REDIS_LIST|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的列表对象。|
      |REDIS_LIST|REDIS_ENCODING_LINKEDLIST|使用双端链表实现的列表对象。|
      |REDIS_HASH|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的哈希对象。|
      |REDIS_HASH|REDIS_ENCODING_HT|使用字典实现的哈希对象。|
      |REDIS_SET|REDIS_ENCODING_INTSET|使用整数集合实现的集合对象。|
      |REDIS_SET|REDIS_ENCODING_HT|使用字典实现的集合对象。|
      |REDIS_ZSET|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的有序集合对象。|
      |REDIS_ZSET|REDIS_ENCODING_SKIPLIST|使用跳跃表和字典实现的有序集合对象。|
   2. 类型检查与命令多态：Redis在执行类型特定的命令之前，会先检查给定键的值对象的类型能否执行指定的命令，这是通过redisObject结构的type属性来实现的；还会根据给定键的值对象的编码方式，选择正确的命令实现代码来执行命令，这是通过redisObject结构的encoding属性来实现的。
   3. 内存回收：Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。每个对象的引用计数信息由redisObject结构的refcount属性记录。
   4. 对象共享：对象的引用计数属性还带有对象共享的作用。受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。
   5. 对象的空转时长：redisObject结构的lru属性记录了对象最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

## 三、单机数据库的实现

1. 数据库
   1. 实现：Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型。
   2. 过期键
      1. 实现：expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。
      2. 删除策略：Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在访问到过期键时才进行删除操作，定期删除策略则每隔一段时间就从一定数量的数据库中随机取出一定数量的键进行检查，并删除其中的过期键。
      3. AOF、RDB和复制功能对过期键的处理
         - RDB：执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。载入RDB文件时，如果服务器以主服务器模式运行，过期键会被忽略；如果服务器以从服务器模式运行，所有键都会被载入到数据库中。
         - AOF：当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显示地删除过期键。执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。
         - 复制：当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显示地删除过期键。从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。
2. RDB持久化
   1. 概念：RDB持久化功能可以将Redis服务器所有数据库中的所有键值对数据保存到RDB文件中，RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。
   2. 执行：有两个Redis命令可以手动执行RDB持久化，SAVE命令由服务器进程直接执行保存操作，会阻塞服务器；BGSAVE命令由子进程执行保存操作，不会阻塞服务器。Redis允许用户设置服务器配置的save选项，当服务器在一段时间内对数据库执行的修改超过一定次数时，自动执行一次BGSAVE命令。服务器状态redisServer结构的saveparams属性记录了save选项所设置的保存条件，dirty计数器记录了距离上一次成功执行SAVE命令或BGSAVE命令之后，服务器对数据库状态进行了多少次修改，lastsave属性记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的UNIX时间戳，通过这三个属性检查save选项所设置的保存条件是否已经满足。
   3. RDB文件
      ![RDB文件结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627115804.png)
      1. database部分
         ![RDB文件中的数据库结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627115936.png)
      2. key_value_pairs部分
         1. 不带过期时间的键值对
            ![不带过期时间的键值对](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627120053.png)
         2. 带过期时间的键值对
            ![带过期时间的键值对](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627120120.png)
         3. value的编码
            1. 字符串对象
               ![INT编码字符串对象的保存结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627120358.png)
               ![无压缩字符串的保存结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627120421.png)
               ![压缩后字符串的保存结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627120438.png)
            2. 列表对象
               ![LINKEDLIST编码列表对象的保存结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627120506.png)
            3. 集合对象
               ![HT编码集合对象的保存结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627120544.png)
            4. 哈希表对象
               ![更详细的HT编码哈希表对象的保存结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627120618.png)
            5. 有序集合对象
               ![更详细的SKIPLIST编码有序集合对象的保存结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627120655.png)
            6. INSET编码的集合：先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件中。
            7. ZIPLIST编码的列表、哈希表或者有序集合：先将压缩列表转换为字符串对象，然后将这个字符串对象保存到RDB文件中。
3. AOF持久化
   1. 概念：AOF持久化是通过保存所有修改数据库的写命令请求来记录服务器的数据库状态，AOF文件中的所有命令都以Redis命令请求协议的格式保存。
   2. 实现：Redis在执行完一个写命令后，会以协议格式将被执行的写命令追加到AOF缓冲区的末尾，之后再定期写入并同步到AOF文件。服务器配置的不同appendfsync的值会产生不同的持久化行为：
      |appendfsync选项的值|         持久化行为        |
      |:----------------:|:-------------------------|
      |     always       |将AOF缓冲区中的所有内容写入并同步到AOF文件|
      |    everysec      |将AOF缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过一秒钟，那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的|
      |      no          |将AOF缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统来决定|
      服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。
   3. AOF重写
      1. 概念：AOF重写功能首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，最后产生一个新的AOF文件，这个新的AOF文件和原来的AOF文件所保存的数据库状态一样，但体积更小。
      2. AOF后台重写：在执行BGREWRITEAOF命令时，Redis会在带有服务器进程的数据副本的子进程中执行AOF重写程序。Redis服务器会维护一个AOF重写缓冲区，当Redis服务器执行完一个写命令之后，会将这个写命令同时发送给AOF缓冲区和AOF重写缓冲区。当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程接收到该信号后，将AOF重写缓冲区中的所有内容写入到新AOF文件中，然后对新的AOF文件进行改名，原子地覆盖现有的AOF文件。
   4. RDB持久化和AOF持久化的对比
      1. Redis载入RDB文件的速度快于载入AOF文件的速度；
      2. 对于同一个数据库状态，RDB文件的体积小于AOF文件的体积；
      3. AOF文件的更新频率通常比RDB文件的更新频率快，服务器会优先载入AOF文件来还原数据库状态。
4. 事件
   1. 概念：
      - Redis服务器是一个事件驱动程序，服务器处理的事件分为文件事件和时间事件两类。
      - 文件事件是对套接字操作的抽象，当套接字变得可应答（acceptable）时（客户端对服务器的监听套接字执行connect操作），或者套接字变得可读（readable）时（客户端对套接字执行write操作，或者执行close操作），套接字产生AE_READABLE事件（读事件）；当套接字变得可写（writable）时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件（写事件）。
      - 时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。
   2. 文件事件
      1. 文件事件处理器：文件事件处理器是基于Reactor模式实现的网络通信程序，由套接字、I/O多路复用程序、文件事件分派器，以及事件处理器四个部分构成。
         - 当套接字准备好执行操作时，与操作相对应的文件事件就会产生。
         - I/O多路复用程序负责监听多个套接字，将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。
         - 文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。
         - 服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，定义了某个事件发生时，服务器应该执行的动作。

         ![文件事件处理器的四个组成部分](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220627171954.png)
      2. I/O多路复用程序：Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，在实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现。
      3. 完整的客户端与服务器连接事件示例：
         1. Redis服务器初始化时，会将服务器监听套接字的AE_READABLE事件与连接应答处理器关联起来。当Redis客户端向服务器发起连接，监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字和客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联；
         2. 之后，当客户端向服务器发送一个命令请求时，客户端套接字将产生AE_READABLE事件，触发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行；
         3. 为了将命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复时，客户端套接字将产生AE_WRITABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。
   3. 时间事件：服务器在一般情况下只执行serverCron函数一个时间事件，并且这个事件是周期性事件。服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。服务器会轮流处理文件事件和时间事件，时间事件在文件事件之后执行，并且处理事件的过程中也不会进行抢占，所以时间事件的实际处理时间通常会比设定的到达时间晚一些。
5. 客户端：服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。客户端状态包括：套接字描述符、名字、标志值、正在使用的数据库、输入缓冲区和输出缓冲区，以及执行相关功能时需要用到的数据结构。
6. 服务端：Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。
   1. 命令请求的执行过程
      1. 客户端将协议格式的命令请求发送给服务器；
      2. 服务器读取命令请求，并分析出命令参数；
      3. 命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；
      4. 服务器将协议格式的命令回复返回给客户端。
   2. serverCron函数默认每隔100毫秒执行一次，它的工作主要包括：
      - 更新服务器时间缓存：为了减少获取系统当前时间的系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存。
      - 更新LRU时钟：服务器状态中的lruclock属性保存了服务器的LRU时钟，用于计算一个数据库键的空转时间。
      - 服务器每秒执行命令次数：以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量。
      - 服务器内存峰值记录
      - 处理服务器接收的SIGTERM信号：对服务器状态的shutdown_asap属性进行检查，判断是否接收到SIGTERM信号，并根据属性的值决定是否关闭服务器。
      - 管理客户端资源：如果客户端与服务器之间的连接已经超时，那么程序释放这个客户端；如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。
      - 管理数据库状态：删除过期键，并在有需要时，对字典进行收缩操作。
      - 检查并执行持久化操作：服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行。
        - 如果rdb_child_pid属性和aof_child_pid属性其中一个不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程，如果有，要么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），需要用新的RDB文件替换现有的RDB文件；要么表示AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），需要用重写后的AOF文件替换现有的AOF文件。如果没有信号到达，程序不做动作。
        - 如果rdb_child_pid属性和aof_child_pid属性都为-1，程序依次判断并执行以下三个动作之一：
           1. 如果有BGREWRITEAOF被延迟了，那么开始一次新的BGREWRITEAOF操作；
           2. 如果服务器的自动保存条件已经被满足，那么服务器开始一次新的BGSAVE操作；
           3. 如果服务器设置的AOF重写条件已经被满足，那么服务器开始一次新的BGREWRITEAOF操作。
      - 将AOF缓冲区中的内容写入AOF文件
   3. 服务器从启动到能够处理客户端的命令请求需要执行以下步骤：1）初始化服务器状态；2）载入服务器配置；3）初始化服务器数据结构；4）还原数据库状态；5）执行事件循环。

## 四、多机服务器的实现

1. 复制
   1. 概念：在Redis中，可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，称被复制的服务器为主服务器（master），对主服务器进行复制的服务器被称为从服务器（slave）。进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”。
      Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态；命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致时，让主从服务器的数据库重新回到一致状态。
   2. 同步：从服务器对主服务器的同步操作需要通过向主服务器发送PSYNC命令来完成，PSYNC命令具有完整重同步和部分重同步两种模式。完整重同步用于处理初次复制情况，部分重同步则用于处理断线后重复制情况。
      - 完整重同步的实现：
         1. 主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令；
         2. 当主服务器的BGSAVE命令执行完毕时，主服务器会将生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件；
         3. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，至此，主从服务器的数据库状态达到一致。
      - 部分重同步
         1. 构成部分：
            - 主从服务器的复制偏移量（replication offset）：主从服务器之间传输的写命令的字节数量。
            - 主服务器的复制积压缓冲区（replication backlog）：主服务器维护的一个固定长度先进先出队列，保存着最近传播的写命令。
            - 服务器的运行ID（run ID）：服务器启动时自动生成的运行ID，由40个随机的十六进制字符组成。
         2. 实现：
            1. 当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来；
            2. 当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID。如果该运行ID与当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作；
            3. 主服务器检查从服务器复制偏移量之后的数据是否存在于复制积压缓冲区中，如果存在则可以执行部分重同步操作；
            4. 主服务器将保存在复制积压缓冲区中从服务器复制偏移量之后的数据发送给从服务器，主从服务器将再次回到一致状态。
   3. 实现：
      1. 设置主服务器的地址和端口：从服务器将客户端给定的主服务器IP地址和端口保存到服务器状态的masterhost属性和masterport属性里面；
      2. 建立套接字连接：在SLAVE命令执行之后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接，从服务器成为主服务器的客户端；
      3. 发送PING命令：检查套接字的读写状态是否正常，检查主服务器能否正常处理命令请求；
      4. 身份验证
      5. 发送端口信息：从服务器向主服务器发送从服务器的监听端口号；
      6. 同步：主服务器成为从服务器的客户端；
      7. 命令传播：主服务器将自己执行的写命令发送给从服务器，从服务器接收并执行主服务器发来的写命令。
   4. 心跳检测：在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令REPLCONF ACK <replication_offset>，有三个作用：检测主从服务器的网络连接状态；辅助实现min_slaves选项；检测命令丢失。
2. Sentinel
   1. 概念：Sentinel（哨岗、哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。
   2. 启动并初始化Sentinel：
      1. 初始化服务器：Sentinel只是一个运行在特殊模式下的Redis服务器；
      2. 将普通Redis服务器使用的代码替换成Sentinel专用代码：Sentinel使用了和普通模式不同的命令表；
      3. 初始化Sentinel状态
      4. 根据给定的配置文件，初始化Sentinel的监视主服务器列表：Sentinel会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构；
      5. 创建连向主服务器的网络连接：Sentinel创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接收指定频道的消息。
   3. 获取服务器信息：
      - Sentinel通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。
      - 在一般情况下，Sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者Sentinel正在对主服务器进行故障转移操作时，Sentinel向从服务器发送INFO命令的频率会改为每秒一次。
   4. 发送和接收频道信息：
      - 对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器的__sentinel__:hello频道发送消息来向其他Sentinel宣告自己的存在。
      - 每个Sentinel也会从__sentinel__:hello频道中接收其他Sentinel发来的信息，并根据这些信息为其他Sentinel创建相应的实例结构，以及命令连接。
   5. 检测下线状态：
      1. Sentinel以每秒一次的频率向实例（包括主服务器、从服务器、其他Sentinel）发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向Sentinel发送无效回复时，Sentinel会将这个实例判断为主观下线；
      2. 当Sentinel将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其他Sentinel进行询问，看它们是否同意这个主服务器已经进入主观下线状态。当Sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。
   6. 选举领头Sentinel：当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。
      Redis选举领头Sentinel的规则和方法：
      - 所有在线的Sentinel都有被选为领头Sentinel的资格。每次进行领头Sentinel选举之后，所有Sentinel的配置纪元的值都会自增一次。在一个配置纪元，每个Sentinel都有且只有一次将某个Sentinel设置为局部领头Sentinel的机会。
      - 每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。Sentinel设置局部领头Sentinel的规则是先到先得：最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel。
      - 如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那个这个Sentinel成为领头Sentinel。
      - 如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止。
   7. 故障转移：
      1. 在已下线主服务器属下的所有从服务器里，挑选出一个从服务器，并将其转换为主服务器；
      2. 让已下线主服务器属下的所有从服务器改为复制新的主服务器；
      3. 将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。
3. 集群
   1. 概念：Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。
   2. 节点：一个节点就是一个运行在集群模式下的Redis服务器，通过使用CLUSTER MEET命令连接其他节点，构成一个包含多个节点的集群。
   3. 槽指派：Redis集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为16384个槽（slot），通过使用CLUSTER ADDSLOTS命令将若干个槽指派给节点负责。每个节点状态结构中都用一个二进制位数组记录哪些槽指派给了该节点，集群状态结构中使用一个长度为16384的数组记录了集群所有槽的指派信息，每个数组项都是一个指向节点状态结构的指针。
   4. 在集群中执行命令：节点在接到一个命令请求时，首先计算这个命令请求要处理的键所在的槽，计算方法是该键的CRC-16校验和对16384的余数。然后检查该槽是否由本节点负责，如果是，那么节点直接执行这个命令，否则，节点将向客户端返回一个MOVED错误，MOVED错误携带了正在负责相关槽的节点的IP地址和端口，可以指引客户端转向该节点。
   5. 重新分片：将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并将相关槽所属的键值对从源节点转移到目标节点。
      1. 实现原理：目标节点中的数组记录了当前节点正在从其他节点导入的槽，源节点中的数组中记录了当前节点正在迁移至其他节点的槽，然后依次将每个需要迁移的槽中的键值对从源节点迁移到目标节点，当所有需要迁移的槽中的所有键值对都迁移完成后，将需要迁移的槽指派给目标节点，最后将该指派信息发送至整个集群，重新分片完成。
      2. ASK错误：如果节点A正在迁移槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B继续查找指定的数据库键。
   6. 复制与故障转移：集群里的从节点用于复制主节点，当主节点下线时，会基于Raft算法的领头选举方法，从所有复制下线主节点的从节点中，选举出一个新的主节点代替原来的主节点继续处理命令请求。
      1. 集群中的每个节点都会定期地向集群中的其他节点发送PING消息，如果接收PING消息的节点没有在规定的时间内返回PONG消息，就会被标记为疑似下线；
      2. 集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，如果半数以上的主节点都将某个主节点报告为疑似下线，那么这个主节点将被标记为已下线；
      3. 将主节点标记为已下线的节点会向集群广播这条消息，复制该下线主节点的从节点接收到该消息后，开始进行故障转移；
      4. 复制该下线主节点的从节点基于Raft算法的领头选举方法，都要求其他主节点给自己投票，收集到超过一半的支持票时，就会当选为新的主节点；
      5. 新的主节点将所有对已下线主节点指派的槽都指派给自己，然后广播一条PONG消息。
