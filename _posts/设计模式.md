# 设计模式

## 一、设计模式之间的关系

![设计模式之间的关系](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711101343.png)

## 二、创建型模式

1. Abstract Factory（抽象工厂）——对象创建型模式
   1. 意图：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。
   2. 适用性：
      - 一个系统要独立于它的产品的创建、组合和表示。
      - 一个系统要由多个产品系列中的一个来配置。
      - 要强调一系列相关的产品对象的设计以便进行联合使用。
      - 要提供一个产品类库，但只想显示它们的接口而不是实现。
   3. 结构
      ![抽象工厂结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711102003.png)
   4. 实现
      1. 当工厂作为单件。
      2. 创建产品。
      3. 定义可扩展的工厂。
   5. 相关模式
      - Abstract Factory类通常用工厂方法（Factory Method）实现，但它们也可以用Prototype实现。
      - 一个具体的工厂通常是一个单件（Singleton）。
2. Builder（生成器）——对象创建型模式
   1. 意图：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
   2. 适用性：
      - 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
      - 当构造过程必须允许被构造的对象有不同的表示时。
   3. 结构
      ![生成器结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711102609.png)
   4. 实现
      1. 装配和构造接口。
      2. 产品没有抽象类。
      3. 在Builder中缺省的方法为空。
   5. 相关模式
      - Builder模式着重于一步步构造一个复杂对象，而Abstract Factory着重于多个系列的产品对象。Builder在最后一步返回产品，而对于Abstract Factory来说，产品是立即返回的。
      - Composite通常是用Builder生成的。
3. Factory Method（工厂方法）——类创建型模式
   1. 意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。
   2. 适用性：
      - 当一个类不知道它所必须创建的对象的类的时候。
      - 当一个类希望由它的子类来指定它所创建的对象的时候。
      - 当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。
   3. 结构
      ![工厂方法结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711103849.png)
   4. 实现
      1. 工厂方法可以有缺省的实现。
      2. 参数化工厂方法。
      3. 特定语言的变化和问题。
      4. 使用模板以避免创建子类。
      5. 命名约定。
   5. 相关模式
      - 工厂方法通常在Template Method中被调用。
4. Prototype（原型）——对象创建型模式
   1. 意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
   2. 适用性：
      - 当一个系统应该独立于它的产品创建、构成和表示时。
      - 当要实例化的类是在运行时指定时，例如，通过动态装载。
      - 为了避免创建一个与产品类层次平行的工厂类层次时。
      - 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
   3. 结构
      ![原型结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711104813.png)
   4. 实现
      1. 使用一个原型管理器。
      2. 实现克隆操作。
      3. 初始化克隆对象。
   5. 相关模式
      - 大量使用Composite和Decorator模式的设计通常也可从Prototype模式获益。
5. Singleton（单件）——对象创建型模式
   1. 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
   2. 适用性：
      1. 当类只能有一个实例并且客户可以从一个众所周知的访问点访问它时。
      2. 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无须更改代码就能使用一个扩展的实例时。
   3. 结构
      ![单件结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711105337.png)
   4. 实现
      1. 保证一个唯一的实例。
      2. 创建Singleton类的子类。
   5. 相关模式
      - Abstract Factory、Builder和Prototype等模式都可以使用Singleton模式实现。

## 三、结构型模式

1. Adapter（适配器）——类对象结构性模式
   1. 意图：将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
   2. 适用性：
      - 想使用一个已经存在的类，而它的接口不符合需求。
      - 想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。
      - （仅适用于对象Adapter）想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。
   3. 结构
      类适配器使用多重继承对一个接口与另一个接口进行匹配，如下图所示。
      ![类适配器结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711155239.png)
      对象适配器依赖于对象组合，如下图所示。
      ![对象适配器结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711155332.png)
   4. 实现
      1. 使用C++实现适配器类时，Adapter类应该采用公共方式继承Target类，并且用私有方式继承Adaptee类。
      2. 可插入的适配器。
   5. 相关模式
      - 模式Bridge的结构与对象适配器类似，但是Bridge模式的出发点不同：Bridge的目的是将接口部分和实现部分分离，从而可以对它们较为容易也相对独立地加以改变。而Adapter则意味着改变一个已有对象的接口。
      - Decorator模式增强了其他对象的功能而同时又不改变它的接口，因此Decorator对应用程序的透明性比适配器要好。
      - 模式Proxy在不改变它的接口的条件下，为另一个对象定义了一个代理。
2. Bridge（桥接）——对象结构性模式
   1. 意图：将抽象部分与它的实现部分分离，使它们可以独立地变化。
   2. 适用性：
      - 不希望在抽象和它的实现部分之间有一个固定的绑定关系。
      - 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。
      - 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。
      - （C++）想对客户完全隐藏抽象的实现部分。
      - 有许多类要生成。
      - 想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。
   3. 结构
      ![桥接结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711160611.png)
   4. 实现
      1. 仅有一个实现的时候，没有必要创建一个抽象的Implementor类。
      2. 创建正确的Implementor对象。
      3. 共享Implementor对象。
      4. 采用多重继承机制。
   5. 相关模式
      - Abstract Factory模式可以用来创建和配置一个特定的Bridge模式。
      - Adapter模式用来帮助无关的类协同工作，它通常在系统设计完成后才会被使用。然后，Bridge模式则是在系统开始时就被使用，它使得抽象接口和实现部分可以独立进行改变。
3. Composite（组合）——对象结构性模式
   1. 意图：将对象组合成树形结构以表示“部分——整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。
   2. 适用性：
      - 想表示对象的部分——整体层次结构。
      - 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
   3. 结构
      ![组合结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711161713.png)
   4. 实现
      1. 显示的父部件引用。
      2. 共享组件。
      3. 最大化Component接口。
      4. 声明管理子部件的操作。
      5. Component是否应该实现一个Component列表。
      6. 子部件排序。
      7. 使用高速缓冲存储改善性能。
      8. 应该由谁删除Component。
      9. 存储组件最好用哪种数据结构。
   5. 相关模式
      - 通常，部件——父部件连接用于Responsibility of Chain模式。
      - Decorator模式经常与Composite模式一起使用。当装饰和组合一起使用时，它们通常有一个公共的子类。
      - Flyweight让你共享组件，但不再能引用其父部件。
      - Iterator可用来遍历Composite。
      - Visitor将本来应该分布在Composite和Leaf类中的操作和行为局部化。
4. Decorator（装饰器）——对象结构型模式
   1. 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。
   2. 适用性：
      - 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
      - 处理那些可以撤销的职责。
      - 当不能采用生成子类的方法进行扩充时。
   3. 结构
      ![装饰器结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711163051.png)
   4. 实现
      1. 接口的一致性。
      2. 当仅需要添加一个职责时，没有必要定义抽象Decorator类。
      3. 保持Component类的简单性。
      4. 改变对象外壳与改变对象内核。
   5. 相关模式
      - Adapter：Decorator模式不同于Adapter模式，因为装饰仅改变对象的职责而不改变它的接口；而适配器将给对象一个全新的接口。
      - Composite：可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责——它的目的不在于对象聚集。
      - Strategy：用一个装饰可以改变对象的外表；而Strategy模式使得你可以改变对象的内核。
5. Facade（外观）——对象结构性模式
   1. 意图：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
   2. 适用性：
      - 要为一个复杂子系统提供一个简单接口时。
      - 客户程序与抽象类的实现部分之间存在着很大的依赖性。
      - 需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。
   3. 结构
      ![外观结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711164559.png)
   4. 实现
      1. 降低客户——子系统之间的耦合度。
      2. 公共子系统类与私有子系统类。
   5. 相关模式
      - Abstract Factory模式可以与Facade模式一起使用以提供一个接口，这一接口可用来以一种子系统独立的方式创建子系统对象。
      - Mediator模式与Facade模式的相似之处是，它抽象了一些已有的类的功能。
      - 通常来讲，仅需要一个Facade对象，因此Facade对象通常属于Singleton模式。
6. Flyweight（享元）——对象结构性模式
   1. 意图：运用共享技术有效地支持大量细粒度的对象。
   2. 适用性：
      - 一个应用程序使用了大量的对象。
      - 完全由于使用大量的对象造成很大的存储开销。
      - 对象的大多数状态都可变为外部状态。
      - 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
      - 应用程序不依赖于对象标识。
   3. 结构
      ![享元结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711165436.png)
   4. 实现
      1. 删除外部状态。
      2. 管理共享对象。
   5. 相关模式
      - Flyweight模式通常和Composite模式结合起来，用共享叶结点的有向无环图实现一个逻辑上的层次结构。
      - 通常，最好用Flyweight实现State和Strategy对象。
7. Proxy（代理）——对象结构性模式
   1. 意图：为其他对象提供一种代理以控制对这个对象的访问。
   2. 适用性：
      - 远程代理为一个对象在不同的地址空间提供局部代表。
      - 虚代理根据需要创建开销很大的对象。
      - 保护代理控制对原始对象的访问。
      - 智能指引取代了简单的指针，它在访问对象时执行一些附加操作。
   3. 结构
      ![代理结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220711170110.png)
   4. 实现
      1. 重载C++中的存取运算符。
      2. Proxy并不总是需要知道实体的类型。
   5. 相关模式
      - Adapter：适配器为它所适配的对象提供了一个不同的接口。相反，代理提供了与它的实体相同的接口。
      - Decorator：尽管装饰的实现部分与代理相似，但装饰的目的不一样。

## 四、行为型模式

1. Chain of Responsibility（职责链）——对象行为型模式
   1. 意图：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
   2. 适用性：
      - 有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定。
      - 想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
      - 可处理一个请求的对象集合应被动态指定。
   3. 结构
      ![职责链结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712082005.png)
   4. 实现
      1. 实现后继者链。
      2. 连接后继者。
      3. 表示请求。
   5. 相关模式
      - 职责链常与Composite一起使用。这种情况下，一个构件的父构件可作为它的后继。
2. Command（命令）——对象行为型模式
   1. 意图：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
   2. 适用性：
      - 抽象出待执行的动作以参数化某对象。
      - 在不同的时刻指定、排列和执行请求。
      - 支持取消操作。
      - 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。
      - 用构建在原语操作上的高层操作构造一个系统。
   3. 结构
      ![命令结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712082936.png)
   4. 实现
      1. 一个命令对象应达到何种智能程度。
      2. 支持撤销（undo）和重做（redo）。
      3. 避免撤销操作过程中的错误积累。
      4. 使用C++模板。
   5. 相关模式
      - Composite可用来实现宏命令。
      - Memento可用来保持某个状态，命令用这一状态来取消它的效果。
      - 在被放入历史列表前必须被拷贝的命令起到一种原型（Prototype）的作用。
3. Interpreter（解释器）——类行为型模式
   1. 意图：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
   2. 适用性：
      - 文法简单。
      - 效率不是关键问题。
   3. 结构
      ![解释器结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712083915.png)
   4. 实现
      1. 构建抽象语法树。
      2. 定义解释操作。
      3. 与Flyweight模式共享终结符。
   5. 相关模式
      - Composite：抽象语法树是一个组合模式的实例。
      - Flyweight：说明了如何在抽象语法树中共享终结符。
      - Iterator：解释器可用一个迭代器遍历该结构。
      - Visitor：可用来在一个类中维护抽象语法树中各结点的行为。
4. Iterator（迭代器）——对象行为型模式
   1. 意图：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
   2. 适用性：
      - 访问一个聚合对象的内容而无须暴露它的内部表示。
      - 支持对聚合对象的多种遍历。
      - 为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）。
   3. 结构
      ![迭代器](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712084540.png)
   4. 实现
      1. 谁控制该迭代。
      2. 谁定义遍历算法。
      3. 迭代器健壮程度如何。
      4. 附加的迭代器操作。
      5. 在C++中使用多态的迭代器。
      6. 迭代器可有特权访问。
      7. 用于组合对象的迭代器。
      8. 空迭代器。
   5. 相关模式
      - Composite：迭代器常被应用到像组合这样的递归结构上。
      - Factory Method：多态迭代器靠Factory Method来实例化适当的迭代器子类。
      - Memento：常与迭代器模式一起使用。迭代器可使用Memento来捕获一个迭代的状态。迭代器在其内部存储Memento。
5. Mediator（中介者）——对象行为型模式
   1. 意图：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
   2. 适用性：
      - 一组对象以定义良好但复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。
      - 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
      - 想定制一个分布在多个类中的行为，而又不想生成太多的子类。
   3. 结构
      ![中介者结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712101921.png)
   4. 实现
      1. 当各Colleague仅与一个Mediator一起工作时，没有必要定义一个抽象的Mediator类。
      2. Colleague-Mediator通信。
   5. 相关模式
      - Facade与中介者的不同之处在于，它是对一个对象子系统进行抽象，从而提供了一个更为方便的接口。
      - Colleague可使用Observer模式与Mediator通信。
6. Memento（备忘录）——对象行为型模式
   1. 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
   2. 适用性：
      - 必须保存一个对象在某个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。
      - 如果一个接口让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。
   3. 结构
      ![备忘录结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712103329.png)
   4. 实现
      1. 语言支持。
      2. 存储增量式改变。
   5. 相关模式
      - Command：命令可使用备忘录来为可撤销的操作维护状态。
      - Iterator：如前所述，备忘录可用于迭代。
7. Observer（观察者）——对象行为型模式
   1. 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
   2. 适用性：
      - 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这二者封装在独立的对象中，以使它们可以各自独立地改变和复用。
      - 对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
      - 一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，不希望这些对象是紧密耦合的。
   3. 结构
      ![观察者结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712162404.png)
   4. 实现
      1. 创建目标到其观察者之间的映射。
      2. 观察多个目标。
      3. 谁触发更新。
      4. 对已删除目标的悬挂引用。
      5. 在发出通知前确保目标的状态自身是一致的。
      6. 避免特定于观察者的更新协议——推/拉模型
      7. 显式地指定感兴趣的改变。
      8. 封装复杂的更新语义。
   5. 相关模式
      - Mediator：通过封装复杂的更新语义，ChangeManager充当目标和观察者之间的中介者。
      - Singleton：ChangeManager可使用Singleton模式来保证它是唯一的并且是全局可访问的。
8. State（状态）——对象行为型模式
   1. 意图：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
   2. 适用性：
      - 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。
      - 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。
   3. 结构
      ![状态结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712163733.png)
   4. 实现
      1. 谁定义状态转换。
      2. 基于表的另一种方法。
      3. 创建和销毁State对象。
   5. 相关模式
      - Flyweight解释了何时以及怎样共享状态对象。
      - 状态对象通常是Singleton。
9. Strategy（策略）——对象行为型模式
   1. 意图：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
   2. 适用性：
      - 许多相关的类仅仅是行为有异。
      - 需要使用一个算法的不同变体。
      - 算法使用客户不应该知道的数据。
      - 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。
   3. 结构
      ![策略结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712164808.png)
   4. 实现
      1. 定义Strategy和Context接口。
      2. 将Strategy作为模板参数。
      3. 使Strategy对象成为可选的。
   5. 相关模式
      - Flyweight：Strategy对象经常是很好的轻量级对象。
10. Template Method（模板方法）——类行为型模式
    1. 意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
    2. 适用性：
       - 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。
       - 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
       - 控制子类扩展。
    3. 结构
       ![模板方法结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712165851.png)
    4. 实现
       1. 使用C++访问控制。
       2. 尽量减少原语操作。
       3. 命名约定。
    5. 相关模式
       - Factory Method常被模板方法调用。
       - Strategy：模板方法使用继承来改变算法的一部分，Strategy使用委托来改变整个算法。
11. Visitor（访问者）——对象行为型模式
    1. 意图：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
    2. 适用性：
       - 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
       - 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。
       - 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。
    3. 结构
       ![访问者结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220712171011.png)
    4. 实现
       1. 谁负责遍历对象结构
    5. 相关模式
       - Composite：访问者可以用于对一个由Composite模式定义的对象结构进行操作。
       - Interpreter：访问者可以用于解释。
