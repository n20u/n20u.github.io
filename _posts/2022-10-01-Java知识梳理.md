# Java知识梳理

## 一、面向对象编程

面向对象的3个基本特征：继承、封装和多态。

新特性：
    1. Java 8：Lambda表达式、接口的默认方法和静态方法、方法引用（含构造器引用）、重复注解、扩展注解的支持、Optional、Stream、Date/Time API。

普通类（非内部类）无法声明为protected的或private的，它们只能被给予public或包访问权限。

类的初始化顺序：
    1. 静态初始化：只在类首次加载时发生一次，先执行父类的静态初始化，后执行子类的静态初始化。
       1. 按照静态字段的定义顺序依次初始化静态字段；
       2. 按照静态初始化块的定义顺序依次执行静态初始化块。
    2. 初始化：每次创建类的实例时都会发生一次，先执行父类的初始化，后执行子类的初始化。
       1. 按照非静态字段的定义顺序依次初始化非静态字段；
       2. 按照实例初始化块的定义顺序依次执行实例初始化块；
       3. 执行构造器。

## 十、接口

接口中的方法的默认访问权限是public，default和static方法可以是private的。当声明一个private方法时，它自动就是default的了，不再需要default关键字。

接口中的字段自动是static、final和public的。

使用接口的原因：
   1. 向上转型为多个基类型；
   2. 防止客户程序员创建此类的对象，并明确这只是一个接口。

接口可以继承多个接口。

```java
interface Monster {
    void menace();
}

interface Lethal {
    void kill();
}

interface Vampire extends Monster, Lethal {
    void drinkBlood();
}
```

可以在类中嵌套接口，就像非嵌套接口一样，它们可以具有public、包访问权限或private的可见性。private接口只能在它们的定义类内实现，在外部使用定义类时只能被视为自身的类型，不能提及它实现了private的接口。
接口之间也可以嵌套，嵌套在另一个接口中的接口自动为public的，不能设为private。当实现一个接口时，并不需要实现嵌套在其中的接口。

## 十一、内部类

- 要在外部类的非静态方法之外的任何地方创建内部类的对象，必须将对象的类型指定为OuterClassName.InnerClassName。
- 当创建一个内部类时，这个内部类的对象中会隐含一个链接，指向用于创建该对象的外围对象。通过该链接，内部类拥有对外围对象所有元素的访问权。
- 要生成外部类对象的引用，可以使用外部类的名字，后面加上句点和this。要让某个对象创建它的某个内部类的对象，可以使用.new语法，在new表达式中提供指向外部类对象的引用。
- 借助实例初始化，可以在效果上为匿名内部类创建一个构造器，不过只能有一个这样的构造器。
- 将内部类设置为static的就是嵌套类，不需要一个外部类对象来创建嵌套类对象，无法从嵌套类对象内部访问非static的外部类对象。
- 普通内部类中不能有static数据、static字段，也不能包含嵌套类，但是嵌套类中可以包含所有这些内容。
- 闭包（closure）是一个可调用的对象，它保留了来自它被创建时所在的作用域的信息。
- 局部内部类不能使用访问权限修饰符，但是它可以访问当前代码块中的常量，以及外围类中的所有成员。局部内部类允许定义具名的构造函数以及重载版本。
- 引入内部类最令人信服的理由：每个内部类都可以独立地继承自一个实现。因此，外部类是否已经继承了某个实现，对内部类并没有限制。

## 十二、集合

record定义的是希望成为数据传输对象（也叫数据载体）的类。当使用record关键字时，编译器会自动生成：
   - private final字段
   - 一个规范的构造器
   - 每个元素都有的访问器方法
   - equals()
   - hashCode()
   - toString()

不能继承record，因为它隐含为final的（而且不能为abstract的）。record也不能继承其他类，但可以实现interface。

record可以嵌套在类中，也可以在某个方法内定义，嵌套和局部的record隐含都是静态的。

可以使用一个紧凑构造器（compact constructor）来添加构造器行为，它看上去像一个构造器，但是没有参数列表。紧凑构造器通常用于验证参数，也可以修改字段的初始化值。

for-in语句可以配合数组或任何实现了Iterable接口的类使用，但这并不是说数组也自动实现了Iterable，也不存在任何自动装箱操作。

![简单集合分类](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/6088197f8dc1ff4bc5831c2a8995c9b.jpg)

## 十三、函数式编程

递归的lambda表达式必须被赋值给一个静态变量或一个实例变量，否则会出现编译错误。

未绑定方法引用（unbound method reference）指的是尚未关联到某个对象的普通（非静态）方法。对于未绑定引用，必须先提供对象，然后才能使用。在未绑定引用的情况下，函数式方法（接口中的单一方法）的签名与方法引用的签名不再完全匹配，第一个参数事实上就是this，并在它的上面调用该方法。

可以捕获对某个构造器的引用，之后通过该引用来调用那个构造器。所有构造器都只有一个名字：::new，构造器引用自动被赋值给不同的接口，调用这里的函数式接口方法意味着调用构造器。

## 十四、流

流是一个与任何特定的存储机制都没有关系的元素序列。事实上，我们说流“没有存储”。

## 十五、异常

使用try块捕捉异常，异常处理程序紧跟在try块之后，用关键字catch来表示，每个catch子句在参数中声明自己能处理哪些类型的异常。如果一个异常被抛出，异常处理机制会去查找参数与异常类型相匹配的第一个处理程序，只会匹配一个catch子句，子类的异常对象可以匹配其基类的处理程序。

异常说明是方法声明的组成部分，出现在参数列表之后，使用关键字throws，后面跟着所有可能被抛出的异常的列表。

Java类Throwable描述了任何可以被当作异常抛出的事物。有两个常用的继承自Throwable的类型：Error和Exception。Error代表的是编译时错误和系统错误，一般不用关心其捕获。Exception有两个子类型：IOException和RuntimeException。RuntimeException包括无法预料的错误和应该在代码中检查的错误。通常不用捕捉RuntimeException，它们是“非检查型异常”。需要在异常说明里说一个方法可能会抛出IOException，它们是“检查型异常”。

使用finally执行清理，无论是否抛出异常，finally子句都会执行。

异常丢失：使用finally子句，在前一个异常被处理之前又抛出一个异常，会导致前一个异常丢失；在finally子句中执行return，会把任何被抛出的异常都压制下来。

使用try-with-resources语句自动关闭。在try后面可以跟一个括号定义，括号中的内容叫作资源说明头（resource specification header）。在try-with-resources定义子句中（也就是括号内）创建的对象必须实现java.lang.AutoCloseable接口，该接口只有一个方法——close()。无论是否抛出异常，在退出try块时都会以与创建顺序相反的顺序调用对象的close()方法。

## 十九、反射

反射：在运行时，发现和使用对象和类的类型信息。

程序中的每个类都有一个Class对象，它包含了与类有关的信息。

Java中有三种形式的反射：
   1. Class.forName("类名") / Object.getClass()
   2. 类名.class
   3. 对象 instanceof 类名 / Class.isInstance(对象)

Class类和java.lang.reflect库一起支持了反射，这个库里包含Field、Method以及Constructor类（每个都实现了Member接口）。可以使用Constructor来创建新的对象，使用get()和set()方法来读取和修改与Field对象关联的字段，使用invoke()方法调用与Method对象关联的方法。还可以调用getFields()、getMethods()和getConstructors()等方法，以返回表示字段、方法和构造器的对象数组。

## 二十、泛型

在类名或接口名后的尖括号内放置若干个类型参数，然后在使用该类或接口的时候再将其替换为实际的类型。

还可以对类内部的方法进行参数化，类自身是不是泛型的和是否存在参数化的方法无关。要定义一个泛型方法，需要将泛型参数列表放在返回值之前。

静态方法没有访问类的泛型类型参数的权限，因此如果要用到泛型能力，它就必须是泛型方法。

泛型代码内部并不存在有关泛型类型参数的可用信息。Java泛型是通过**类型擦除**实现的，泛型类型参数会被擦除为其非泛型上界。

类型擦除导致泛型代码无法用于需要显示引用运行时类型的操作，比如类型转换、instanceof操作，以及new表达式。可以通过引入**类型标签**(type tag)来补偿类型擦除导致的损失，意味着要在类型表达式中显示地为要使用的类型传入一个Class对象。

基类通配符允许读操作，超类通配符允许写操作，无界通配符表示某种具体类型。

泛型的限制：
   1. 基本类型不可作为类型参数。
   2. 一个类无法实现同一个泛型接口的两种变体。
   3. 对类型参数使用类型转换或instanceof是没有任何效果的。
   4. 不同的类型参数在重载时会产生相同类型的签名。
   5. 基类会劫持接口。

## 自动内存管理

1. Java内存区域与内存溢出异常
   1. 运行时数据区域
      ![Java虚拟机运行时数据区](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220805103117.png)
      1. 程序计数器(Program Counter Register)：当前线程所执行的字节码的行号指示器，每条线程都需要有一个独立的程序计数器，这是线程私有的内存。
      2. Java虚拟机栈(Java Virtual Machine Stack)：这是线程私有的内存。每个Java方法被调用的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
      3. 本地方法栈(Native Method Stacks)：与虚拟机栈发挥的作用非常相似，只不过是为虚拟机使用到的本地(Native)方法服务。
      4. Java堆(Java Heap)：被所有线程共享的一块内存区域，“几乎”所有的Java对象实例都在这里分配内存。由于即时编译技术和逃逸分析技术的进步，栈上分配、标量替换优化手段的出现，以及日后可能出现值类型的支持，Java对象实例不再是绝对都分配在堆上。
      5. 方法区(Method Area)：被所有线程共享的一块内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
         运行时常量池是方法区的一部分，用于存放类在编译器生成的各种字面量与符号引用，以及由符号引用翻译出来的直接引用。
   2. HotSpot虚拟机Java堆中的对象
      1. 对象的创建
         1. 检查对应的类是否已被加载、解析和初始化过，如果没有，就执行相应的类加载过程；
         2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存；
         3. 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值；
         4. 虚拟机对对象头进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息；
         5. 最后执行\<init\>()方法，按照程序员的意愿对对象进行初始化。
      2. 对象的内存布局
         1. 对象头(Header)：第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；第二类是类型指针，指向对象的类型元数据的指针，但并不是所有的虚拟机实现都在对象头上保留类型指针。
         2. 实例数据(Instance Data)：从父类继承下来的，和在子类中定义的各种类型的字段内容。
         3. 对齐填充(Padding)：对象起始地址必须是8字节的整数倍。
      3. 对象的访问定位：主流的访问方式主要有使用句柄和直接指针两种。

## 垃圾收集算法

1. 可达性分析算法：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。
   在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：
   - 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
   - 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
   - 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
   - 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
   - Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryException）等，还有系统类加载器。
   - 所有被同步锁（synchronized关键字）持有的对象。
   - 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
2. 分代收集理论：一套符合大多数程序运行实际情况的经验法则，它建立在三个分代假说上：
   1. 弱分代假说：绝大多数对象都是朝生夕灭。
   2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。
   3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。
3. 垃圾收集算法
   1. 标记——清除算法：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。
      主要缺点：
      1. 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；
      2. 内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
   2. 标记——复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉。
      如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。
      这种复制回收算法的代价是将可用内存缩小为了原来的一半。一般用于新生代的回收。
   3. 标记——整理算法：首先标记出所有存活的对象，然后让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
      不移动对象垃圾收集的停顿时间会更短，但内存分配时会更复杂；移动对象则内存回收时会更复杂，但能提高整个程序的吞吐量。
4. HotSpot的算法细节实现
   1. 根节点枚举：使用一组OopMap的数据结构来直接得到哪些地方存放着对象引用。
   2. 安全点：只是为特定的指令生成了OopMap，这些位置被称为安全点。
   3. 安全区域：能够确保在某一段代码片段之中，引用关系不会发生变化。
   4. 记忆集与卡表：记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。当记录精度为“卡精度”时，每个记录精确到一块内存区域，该区域内有对象含有跨代指针，也即是用“卡表”(Card Table)去实现记忆集。
   5. 写屏障：在引用对象赋值时会产生一个环形通知，供程序执行额外的动作。
   6. 并发的可达性分析：为解决并发扫描时的对象消失问题，有两种解决方案：增量更新和原始快照。增量更新会记录新插入的黑色对象指向白色对象的引用关系，原始快照会记录删除的灰色对象指向白色对象的引用关系，在并发扫描结束后，再重新扫描一次这些记录的引用关系。
5. 垃圾收集器
   1. Serial收集器：HotSpot虚拟机运行在客户端模式下的默认新生代收集器。采用标记——复制算法回收新生代，进行垃圾收集时，必须暂停其他所有工作，直到它收集结束。额外内存消耗最小，单线程收集效率最高。
   2. ParNew收集器：Serial收集器的多线程并行版本，唯一一款能和CMS收集器配合工作的新生代收集器。
   3. Parallel Scavenge收集器：和ParNew收集器非常相似，但其目标是达到一个可控制的吞吐量。
   4. Serial Old收集器：Serial收集器的老年代版本，基于标记——整理算法实现的老年代收集器。
   5. Parallel Old收集器：Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记——整理算法实现。
   6. CMS收集器：一种以获取最短回收停顿时间为目标的基于标记——清除算法实现的老年代收集器。运作过程分为四个步骤：初始标记、并发标记、重新标记(增量更新)、并发清除。
      缺点：对处理器资源非常敏感；无法处理“浮动垃圾”，有可能出现“并发失败”进而导致另一次完全“Stop The World”的Full GC的产生；收集结束时会有大量空间碎片产生。
   7. Garbage First收集器：把连续的Java堆划分为多个大小相等的独立区域（Region），G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值收益最大的那些Region。运作过程分为四个步骤：初始标记、并发标记、最终标记(原始快照)、筛选回收。
   8. Shenandoah收集器：支持并发的整理算法(读屏障和转发指针)、默认不使用分代收集、用“连接矩阵”的全局数据结构来记录跨Region的引用关系。
   9. ZGC收集器：一款基于Region内存布局的，(暂时)不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记——整理算法的，以低延迟为首要目标的垃圾收集器。

   HotSpot虚拟机运行在客户端模式下的默认垃圾收集器是Serial收集器和Serial Old收集器，运行在服务端模式下默认垃圾收集器在JDK8及以前是Parallel Scavenge收集器和Parallel Old收集器，在JDK9及以后是G1收集器。
   各款垃圾收集器的并发情况：
   ![各款垃圾收集器的并发情况](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220806092811.png)

## 类文件结构

Class文件是一组以8个字节为基础单位的二进制流，只有两种数据类型：“无符号数”和“表”，表是由多个无符号数或者其他表作为数据项构成的复合数据类型。Class文件格式如下所示：
| 类型 |  名称  |   数量   |
|:----|:------|:---------|
|  u4  | magic |   1   |
|  u2  |minor_version| 1 |
|  u2  |major_version| 1 |
|  u2  |constant_pool_count| 1 |
|cp_info|constant_pool|constant_pool_count-1|
|  u2  |access_flags| 1 |
|  u2  |this_class| 1 |
|  u2  |super_class| 1 |
|  u2  |interfaces_count| 1 |
|  u2  |interfaces|interfaces_count|
|  u2  |fields_count| 1 |
|field_info|fields|fields_count|
|  u2  |methods_count| 1 |
|method_info|methods|methods_count|
|  u2  |attributes_count| 1 |
|attribute_info|attributes|attributes_count|

1. Class类文件的结构：
   1. 魔数(0xCAFFBABE)与Class文件的版本(次版本号与主版本号)
   2. 常量池
   3. 访问标志
   4. 类索引、父类索引与接口索引集合
   5. 字段表集合
   6. 方法表集合
   7. 属性表集合：Code(Java代码编译成的字节码指令)、ConstantValue(由final关键字定义的常量值)、Deprecated(被声明为deprecated的方法和字段)和Exceptions(方法抛出的异常列表)等。

   其中字段表与方法表的结构都如下：
   | 类型 | 名称 | 数量 |
   |:----|:-----|:-----|
   |  u2  |access_flags| 1 |
   |  u2  |name_index| 1 |
   |  u2  |descriptor_index| 1 |
   |  u2  |attributes_count| 1 |
   |attribute_info|attributes|attributes_count|
2. 字节码指令：由一个字节长度的操作码(Opcode)以及跟随其后的零至多个操作数(Operand)构成。包括：加载和存储指令、运算指令、类型转换指令、对象创建与访问指令、操作数栈管理指令、控制转移指令、方法调用和返回指令、异常处理指令和同步指令。

## 虚拟机类加载机制

类的声明周期：
![类的生命周期](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220807171443.png)

1. 类加载的过程
   1. 加载
      1. 通过一个类的全限定名来获取定义此类的二进制字节流；
      2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
      3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
   2. 验证：确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。
      1. 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
      2. 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。
      3. 字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
      4. 符号引用验证：对类自身以外的各类信息进行匹配性校验，判断该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。
   3. 准备：正式为类中定义的变量(即静态变量)分配内存并设置初始值。
   4. 解析：将常量池内的符号引用替换为直接引用。
   5. 初始化：执行类构造器\<clinit\>方法。\<clinit\>方法是由编译器自动按照定义顺序收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。
2. 类加载器
   1. 双亲委派模型：除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。类加载器之间的父子关系一般不是以继承的关系来实现的，通常使用组合关系来复用父加载器的代码。
      工作过程：一个类加载器收到类加载的请求后，它首先把这个请求委派给父类加载器去完成，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。
      好处：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，双亲委派模型能够保证无论哪一个类加载器要加载某个类，最终都是委派给一个相对应的类加载器加载。
   2. JDK 8及之前版本
      类加载器双亲委派模型：
      ![类加载器双亲委派模型](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220807205324.png)
   3. JDK 9及之后版本
      类加载器双亲委派模型：
      ![类加载器双亲委派模型](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220807205550.png)

## 虚拟机字节码执行引擎

1. 运行时栈帧结构：Java虚拟机以方法作为最基本的执行单元，“栈帧”则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。
   1. 局部变量表：一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
   2. 操作数栈：用于存放字节码指令中涉及的操作数。
   3. 动态连接：指向运行时常量池中该栈帧所属方法的引用。
   4. 方法返回地址：主调方法的PC计数器的值。
2. 方法调用：确定被调用方法的版本。
   1. 解析：静态方法、私有方法、实例构造器、父类方法，再加上被final修饰的方法，这5种方法调用会在类加载时就把符号引用解析为该方法的直接引用。
   2. 分派
      1. 静态分派：依赖静态类型来决定方法执行版本的分派动作。典型应用表现是方法重载。
      2. 动态分派：根据实际类型来决定方法执行版本的分派动作。典型应用表现是方法重写。
      3. 单分派和多分派：方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。如今的Java语言是一门静态多分派、动态单分派的语言。
      4. 虚拟机动态分派的实现：为类型在方法区中建立一个虚方法表。
3. 基于栈的字节码解释执行引擎
   编译过程：
      ![编译过程](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220810221529.png)
   Javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构，里面的指令大部分是零地址指令，它们依赖操作数栈进行工作。
   基于栈的指令集的优缺点：
      - 优点：可移植、代码相对紧凑、编译器实现更加简单等。
      - 缺点：理论上执行速度会更慢(由于指令数量和内存访问的原因)。

## 前端编译与优化

1. 编译过程
   ![Javac的编译过程](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220813195825.png)
   1. 准备过程：初始化插入式注解处理器。
   2. 解析与填充符号表
      - 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。
      - 填充符号表。产生符号地址和符号信息。
   3. 插入式注解处理器的注解处理
   4. 语义分析与字节码生成过程
      - 标注检查。对语法的静态信息进行检查。
      - 数据流及控制流分析。对程序动态运行过程进行检查。
      - 解语法糖。将简化代码编写的语法糖还原为原有的形式。
      - 字节码生成。将前面各个步骤所生成的信息转化为字节码。
2. Java语法糖
   1. 泛型：本质是参数化类型或者参数化多态的应用，即可以将操作的数据类型指定为签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。
      实现方式：类型擦除。在编译时将参数类型擦除，将泛型类型都变回裸类型，只在元素访问、修改时自动插入一些强制类型转换和检查指令。
      缺陷：
         1. 无法支持原生类型的泛型。
         2. 运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦。
         3. 丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况。例如类型擦除会把方法的特征签名变得一模一样，导致无法重载，但将方法的返回类型改变后又可以重载。
   2. 自动装箱、拆箱与遍历循环
   3. 条件编译：条件为常量的if语句。

## 后端编译与优化

1. 即时编译器
   1. 编译层次
   2. 编译对象与触发条件
      1. 编译对象：被多次调用的方法、被多次执行的循环体。
      2. 热点探测判定方法
         - 基于采样的热点探测
         - 基于计数器的热点探测
   3. 编译过程
      ![Client Compiler架构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220813202527.png)
2. 提前编译器
3. 编译器优化技术
   1. 方法内联：把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用。
   2. 逃逸分析
   3. 公共子表达式消除：如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式，只需要直接用前面计算过的表达式结果代替E。
   4. 数组边界检查消除

## Java内存模型与线程

1. Java内存模型
   1. 主内存与工作内存：所有的变量都存储在主内存中，每条线程有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本。线程对变量的所有操作都只能在自己的工作内存中进行，不能直接读写主内存中的数据。线程间变量值的传递需要通过主内存进行。
      ![线程、主内存、工作内存三者的交互关系](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220812102812.png)
   2. 内存间交互操作：关于主内存与工作内存之间具体的交互协议，Java内存模型中定义了8种原子操作来完成：
      - lock(锁定)
      - unlock(解锁)
      - read(读取)
      - load(载入)
      - use(使用)
      - assign(赋值)
      - store(存储)
      - write(写入)
   3. volatile型变量的语义：1、保证此变量对所有线程的可见性；2、禁止指令重排序优化。
2. Java线程
      1. 实现：每一个Java线程都是直接映射到一个操作系统内核线程来实现的，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
      2. 状态
         Java语言定义了6种线程状态：
            - 新建(New)
            - 运行(Runnable)
            - 无限期等待(Waiting)
            - 限期等待(Timed Waiting)
            - 阻塞(Blocked)
            - 结束(Terminated)

         上述6种状态的转换关系如下图所示：
            ![线程状态转换关系](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220812104642.png)

## 线程安全与锁优化

1. 线程安全
   1. 实现方法
      1. 互斥同步：临界区、互斥量、信号量。
      2. 非阻塞同步：基于冲突检测的乐观并发策略。
      3. 无同步方案：可重入代码、线程本地存储。
2. 锁优化
   1. 自旋锁与自适应自旋
      - 自旋锁：当锁被某个线程持有时，让后面请求锁的线程执行一个忙循环(自旋)，看看持有锁的线程是否很快就会释放锁。
      - 自适应自旋：由前一次在同一个锁上的自旋时间及锁的拥有者的状态，来决定自旋的时间。
   2. 锁消除：虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。
   3. 锁粗化：如果虚拟机探测到一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。
   4. 轻量级锁
      对象的对象头在不同状态下的存储内容如下表所示：
         ![对象头Mark Word](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220812110629.png)
      工作过程：
         - 加锁
         - 解锁
   5. 偏向锁
      偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示：
         ![偏向锁、轻量级锁的状态转化及对象Mark Word的关系](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220812111042.png)
