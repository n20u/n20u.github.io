---
categories: [知识梳理]
img_url: assets/img/posts/Java知识梳理
---
# Java知识梳理

## 一、面向对象编程

面向对象的3个基本特征：继承、封装和多态。

新特性：
    1. Java 8：Lambda表达式、接口的默认方法和静态方法、方法引用（含构造器引用）、重复注解、扩展注解的支持、Optional、Stream、Date/Time API。

普通类（非内部类）无法声明为protected的或private的，它们只能被给予public或包访问权限。

类的初始化顺序：
   1. 将存储空间初始化为二进制零。
   2. 静态初始化：只在类首次加载时发生一次，先执行父类的静态初始化，后执行子类的静态初始化。
       1. 按照静态字段的定义顺序依次初始化静态字段；
       2. 按照静态初始化块的定义顺序依次执行静态初始化块。
   3. 初始化：每次创建类的实例时都会发生一次，先执行父类的初始化，后执行子类的初始化。
       1. 按照非静态字段的定义顺序依次初始化非静态字段；
       2. 按照实例初始化块的定义顺序依次执行实例初始化块；
       3. 执行构造器。

## 二、接口
- 使用接口的原因：
   1. 向上转型为多个基类型；
   2. 防止客户程序员创建此类的对象，并明确这只是一个接口。
- 接口中的方法的默认访问权限是public，default和static方法可以是private的。当声明一个private方法时，它自动就是default的了，不再需要default关键字。
- 接口中的字段自动是static、final和public的。
- 接口可以继承多个接口：
   ```java
   interface Monster {
      void menace();
   }

   interface Lethal {
      void kill();
   }

   interface Vampire extends Monster, Lethal {
      void drinkBlood();
   }
   ```
- 可以在类中嵌套接口，就像非嵌套接口一样，它们可以具有public、包访问权限或private的可见性。
- 接口中嵌套的类自动是public和static的，可以在嵌套类内实现包围它的这个接口。
- private接口只能在它们的定义类内实现，在外部使用定义类时只能被视为自身的类型，不能提及它实现了private的接口。
- 接口之间也可以嵌套，嵌套在另一个接口中的接口自动为public的，不能设为private。当实现一个接口时，并不需要实现嵌套在其中的接口。

## 三、内部类

- 要在外部类的非静态方法之外的任何地方创建内部类的对象，必须将对象的类型指定为OuterClassName.InnerClassName。
- 当创建一个内部类时，这个内部类的对象中会隐含一个链接，指向用于创建该对象的外围对象。通过该链接，内部类拥有对外围对象所有元素的访问权。
- 要生成外部类对象的引用，可以使用外部类的名字，后面加上句点和this。要让某个对象创建它的某个内部类的对象，可以使用.new语法，在new表达式中提供指向外部类对象的引用。
- 如果定义匿名内部类时要用到一个在该匿名类之外定义的对象，编译器要求对象引用用final修饰，或者是“实际上的最终变量”。
- 借助实例初始化，可以在效果上为匿名内部类创建一个构造器，不过只能有一个这样的构造器。
- 将内部类设置为static的就是嵌套类，不需要一个外部类对象来创建嵌套类对象，无法从嵌套类对象内部访问非static的外部类对象。
- 普通内部类中不能有static数据、static字段，也不能包含嵌套类，但是嵌套类中可以包含所有这些内容。
- 局部内部类不能使用访问权限修饰符，但是它可以访问当前代码块中的常量，以及外围类中的所有成员。局部内部类允许定义具名的构造函数以及重载版本。
- 引入内部类最令人信服的理由：每个内部类都可以独立地继承自一个实现。因此，外部类是否已经继承了某个实现，对内部类并没有限制。
- 继承内部类时，不能使用无参构造器，需要在构造器中传递一个指向其外部类对象的引用的参数，并且在构造器内使用如下语法：`outerClassReference.super()`。

## 四、集合

![简单集合分类]({{ page.img_url }}/简单集合分类.jpg)

1. [List](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/List.html)
   - ArrayList：随机访问性能较好，插入或删除性能较差。
   - LinkedList：顺序访问性能较好，插入或删除性能较好，随机访问性能较差，比ArrayList提供了更多功能。
2. [Set](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Set.html)：HashSet中的对象无序，TreeSet以升序保存对象，LinkedHashSet按照添加顺序保存对象。
3. [Map](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Map.html)：HashMap中的键值对无序，TreeMap以升序保存键值对，LinkedHashMap按照添加顺序保存键值对。
4. Stack：Java 6加入了ArrayDeque，实现了栈功能。
5. Queue：LinkedList实现了Queue。Java 5中添加了PriorityQueue，实现了优先级队列。
6. Iterator
   - 迭代器是一个对象，它可以在序列中移动，并用来选择该序列中的每个对象。
   - ListIterator是Iterator的一种更为强大的子类型，只有List类会生成。Iterator只能向前移动，ListIterator可以双向移动。
   - for-in语句可以配合数组或任何实现了Iterable接口的类使用，但这并不是说数组也自动实现了Iterable，也不存在任何自动装箱操作。
7. 集合有一个[java.util.Collections](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Collections.html)的伴生类，包含很多静态的工具方法。
8. record
   - record定义的是希望成为数据传输对象（也叫数据载体）的类。当使用record关键字时，编译器会自动生成：
      - private final字段
      - 一个规范的构造器
      - 每个元素都有的访问器方法
      - equals()
      - hashCode()
      - toString()
   - 不能在record定义体中添加字段，只能将其定义在头部，但可以加入方法、初始化器和静态的字段，方法只能**读取**字段。
   - 不能继承record，因为它隐含为final的（而且不能为abstract的）。record也不能继承其他类，但可以实现interface。
   - record可以嵌套在类中，也可以在某个方法内定义，嵌套和局部的record隐含都是静态的。
   - 可以使用一个紧凑构造器（compact constructor）来添加构造器行为，它看上去像一个构造器，但是没有参数列表。紧凑构造器通常用于验证参数，也可以修改字段的初始化值。
9. 持有引用
   1. [java.lang.ref](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/ref/package-summary.html)库中有3个继承自抽象类Reference的类：SoftReference、WeakReference和PhantomReference，作为和普通引用之间的中介，可达性依次渐弱。
      - SoftReference软引用用于实现对内存敏感的缓存。
      - WeakReference弱引用用于实现规范映射——为节省存储空间，对象的实例可以同时在程序中的多个位置使用——这不会妨碍它们的键（或值）被回收。
      - PhantomReference虚引用用于以更灵活的方式安排事后清理动作。
      - 在使用SoftReference和WeakReference时，可以选择是否将其放到一个ReferenceQueue中（该队列用于事后清理动作），但是PhantomReference只能放到ReferenceQueue中。
   2. WeakHashMap

      Java集合类库中的WeakHashMap持有的是弱引用，允许垃圾收集器自动清理不用的值，其中的键和值自动被该映射包在WeakReference中。

## 五、函数式编程

- lambda表达式的基本语法如下：
   1. 参数。只有一个参数时，可以只写这个参数，不写括号。没有参数或者有多个参数时，**必须**使用括号指示参数列表。
   2. 后面跟->，可以读作“产生”(produces)。
   3. ->后面的都是方法体。方法体只有一行时，方法体中表达式的结果会自动成为lambda表达式的返回值。方法体有多行时，必须将这些代码放到花括号中。
- 递归的lambda表达式必须被赋值给一个静态变量或一个实例变量，否则会出现编译错误。
- 方法引用有两种形式：类名::静态方法名；或对象名::非静态方法名。
- 未绑定方法引用（unbound method reference）指的是尚未关联到某个对象的非静态方法，形式为：类名::非静态方法名。对于未绑定引用，必须先提供对象，然后才能使用。在未绑定引用的情况下，函数式方法（接口中的单一方法）的签名与方法引用的签名不再完全匹配，第一个参数事实上就是this，并在它的上面调用该方法。
- 可以捕获对某个构造器的引用，之后通过该引用来调用那个构造器。所有构造器都只有一个名字：::new，构造器引用自动被赋值给不同的接口，调用这里的函数式接口方法意味着调用构造器。
- 函数式接口：
   为了让编译器确保类型的正确性，Java 8引入了包含一组接口的java.util.function，这些接口是lambda表达式和方法引用的目标类型。每个接口都只包含一个抽象方法，叫作**函数式方法**。
- 闭包（closure）是一个可调用的对象，它保留了来自它被创建时所在的作用域的信息。闭包**捕获的变量**必须是“实际上的最终变量”。
- 函数组合：将多个函数结合使用，以创建新的函数。java.util.function中的一些接口也包含了支持函数组合的方法。
- 柯里化和部分求值：将一个接受多个参数的函数转变为一系列只接受一个参数的函数。

## 六、流

流是一个与任何特定的存储机制都没有关系的元素序列。事实上，我们说流“没有存储”。
流是惰性求值的。

1. 流的创建
   -  ```Java
      public interface Stream<T> extends BaseStream<T,Stream<T>> {
         ...
         static <T> Stream<T> generate(Supplier<? extends T> s);
         static <T> Stream<T> iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next);
         static <T> Stream<T> iterate(T seed, UnaryOperator<T> f);
         static <T> Stream<T> of(T t);
         @SafeVarargs
         static <T> Stream<T> of(T... values);
         static <T> Stream<T> ofNullable(T t);
         ...
      }
      ```
   - 每个Collection都可以使用stream()方法来生成一个流。
   - 随机数流：Random类有一组可以生成流的方法。
   - IntStream类提供了一个range()方法，可以生成一个流——由int值组成的序列。
   - 流生成器
      ```Java
      public static interface Stream.Builder<T> extends Consumer<T> {
         void accept(T t);
         default Stream.Builder<T> add(T t) {
            accept(t)
            return this;
         }
         Stream<T> build();
      }
      ```
   - Arrays类中名为stream()的静态方法，可以将数组转换为流。
   - Java 8向java.util.regex.Pattern类中加入了一个新方法splitAsStream()，它接收一个字符序列，根据**正则表达式**将其分割为一个流。
2. 中间操作
   ```Java
   public interface Stream<T> extends BaseStream<T,Stream<T>> {
      ...
      // 跟踪与调试
      Stream<T> peek(Consumer<? super T> action); // 查看流对象而不修改它们

      // 对流元素进行排序
      Stream<T> sorted();
      Stream<T> sorted(Comparator<? super T> comparator);

      // 移除元素
      Stream<T> distinct(); // 移除流中的重复元素
      Stream<T> filter(Predicate<? super T> predicate); // 只保留符合特定条件的元素
      Stream<T> skip(long n); // 跳过n个元素

      // 将函数应用于每个流元素
      <R> Stream<R> map(Function<? super T, ? extends R> mapper);
      IntStream mapToInt(ToIntFunction<? super T> mapper);
      LongStream mapToLong(ToLongFunction<? super T> mapper);
      DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper);

      // 在应用map()期间组合流
      <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
      IntStream flatMapToInt(Function<? super T,? extends IntStream> mapper);
      LongStream flatMapToLong(Function<? super T,? extends LongStream> mapper);
      DoubleStream flatMapToDouble(Function<? super T,? extends DoubleStream> mapper);
      ...
   }
   ```
3. Optional类型
   Optional对象可以作为流元素来占位，当结果不存在时不会抛出异常。
   ```Java
   public final class Optional<T> {
      ...
      // 便捷函数
      public void ifPresent(Consumer<? super T> action); // 如果值存在，则用这个值来调用Consumer，否则什么都不做
      public void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction); // 如果值存在，则用这个值来调用Consumer，否则执行Runnable
      public T orElse(T other); // 如果值存在，则返回这个值，否则返回other
      public T orElseGet(Supplier<? extends T> supplier); // 如果值存在，则返回这个值，否则返回使用Supplier函数创建的替代值
      public T orElseThrow(); // 如果值存在，则返回这个值，否则抛出NoSuchElementException
      public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X; // 如果值存在，则返回这个值，否则抛出一个使用Supplier函数创建的异常

      // 创建Optional
      public static <T> Optional<T> empty(); // 返回一个空的Optional
      public static <T> Optional<T> of(T value); // 将一个非null值包在一个Optional中
      public static <T> Optional<T> ofNullable(T value); // 如果value为null，返回Optional.empty()，否则将value包在一个Optional中

      // Optional对象上的操作
      public Optional<T> filter(Predicate<? super T> predicate); // 将Predicate应用于Optional的值，并返回其结果
      public <U> Optional<U> map(Function<? super T, ? extends U> mapper); // 将Function应用于Optional的值，并返回其结果
      public <U> Optional<U> flatMap(Function<? super T, ? extends Optional<? extends U>> mapper); // 和map类似，但所提供的映射函数会直接返回一个Optional
      ...
   }
   ```

4. 终结操作
   ```Java
   public interface Stream<T> extends BaseStream<T,Stream<T>> {
      ...
      // 将流转换为一个数组
      Object[] toArray(); // 将流元素转换到适当类型的数组中
      <A> A[] toArray(IntFunction<A[]> generator); // generator用于在特定情况下分配自己的数组存储

      // 在每个流元素上应用某个终结操作
      void forEach(Consumer<? super T> action);
      void forEachOrdered(Consumer<? super T> action); // 确保对元素的操作顺序是原始的流的顺序

      // 收集操作
      <R,A> R collect(Collector<? super T,A,R> collector); // 将流元素累加到一个结果集合中
      <R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner); // Supplier创建一个新的结果集合，第一个BiConsumer将下一个元素包含到结果中，第二个BiConsumer将两个值组合起来

      // 组合所有的流元素
      Optional<T> reduce(BinaryOperator<T> accumulator); // 使用BinaryOperator组合所有的流元素
      T reduce(T identity, BinaryOperator<T> accumulator); // 和上面一样，但将identity用作这个组合的初始值
      <U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner); // 使用给定的初始值，累加器和组合器来组合所有的流元素

      // 匹配
      boolean allMatch(Predicate<? super T> predicate);
      boolean anyMatch(Predicate<? super T> predicate);
      boolean noneMatch(Predicate<? super T> predicate);

      // 选择一个元素
      Optional<T> findFirst();
      Optional<T> findAny();

      // 获得流相关的信息
      long count();
      Optional<T> max(Comparator<? super T> comparator);
      Optional<T> min(Comparator<? super T> comparator);
      ...
   }

   // 获得数值化流相关的信息
   average();
   max();
   min();
   sum();
   summaryStatistics(); // 返回可能有用的摘要数据
   ```
5. 并行流：通过使用.parallel()，可以得到并行流。

## 七、异常

- 使用try块捕捉异常，异常处理程序紧跟在try块之后，用关键字catch来表示，每个catch子句在参数中声明自己能处理哪些类型的异常。如果一个异常被抛出，异常处理机制会去查找参数与异常类型相匹配的第一个处理程序，只会匹配一个catch子句，子类的异常对象可以匹配其基类的处理程序。
- 异常说明是方法声明的组成部分，出现在参数列表之后，使用关键字throws，后面跟着所有可能被抛出的异常的列表。
- Java 7提供了多重捕捉处理程序，可以在一个catch子句中用“|”操作符把不同类型的异常连接起来。
   ```Java
   try {
      /*
         ...
      */
   } catch(Exception1 | Exception2 | Exception3 e) {
      process();
   }
   ```
- 可以重新抛出刚捕获的异常，也可以重新抛出一个与所捕获的异常不同的异常。
- Java类Throwable描述了任何可以被当作异常抛出的事物。有两个常用的继承自Throwable的类型：Error和Exception。Error代表的是编译时错误和系统错误，一般不用关心其捕获。Exception有两个子类型：IOException和RuntimeException。RuntimeException包括无法预料的错误和应该在代码中检查的错误。通常不用捕捉RuntimeException，它们是“非检查型异常”。需要在异常说明里说一个方法可能会抛出IOException，它们是“检查型异常”。
- 使用finally执行清理，无论是否抛出异常，finally子句都会执行。
- 异常丢失：使用finally子句，在前一个异常被处理之前又抛出一个异常，会导致前一个异常丢失；在finally子句中执行return，会把任何被抛出的异常都压制下来。
- 异常的约束：
   - 子类实现的接口中的方法**不能**改变基类中的方法的异常说明。
   - 子类构造器可以抛出任何异常，但必须包含基类构造器异常说明中的异常。子类构造器不能捕捉基类构造器抛出的异常。
   - 基类方法抛出了异常，子类的重写方法可以不抛出异常，也可以抛出其基类版本所说明的异常的子类。
   - 对象向上转型为基类类型时，编译器会（正确地）强制程序捕捉基类声明会抛出的异常。
- 构造器会抛出异常时，为对象的构造创建一个try-catch块。构造完对象后，创建一个try-finally块，在finally子句中执行对象的清理。
- 使用try-with-resources语句自动关闭。在try后面可以跟一个括号定义，括号中的内容叫作资源说明头（resource specification header）。在try-with-resources定义子句中（也就是括号内）创建的对象必须实现java.lang.AutoCloseable接口，该接口只有一个方法——close()。无论是否抛出异常，在退出try块时都会以与创建顺序相反的顺序调用对象的close()方法。

## 八、代码校验

1. JUnit
   - @Test注解标注测试的每个方法。
   - @BeforeAll注解标注的方法在所有测试执行之前运行一次。@AfterAll注解标注的方法在所有测试执行之后运行一次。两种方法都必须是静态的。
   - @BeforeEach注解标注的方法在每次测试执行之前运行，通常用于创建和初始化一组公共对象。@AfterEach注解标注的方法在每次测试执行之后运行，通常用于执行清理。
2. 日志

   SLF4J（Simple Logging Facade for Java）为多个日志框架提供了一个统一的门面。
3. 调试

   Java调试器（JDB）是JDK附带的命令行工具。使用图形调试器跟踪错误更有效率。
4. 基准测试

   Java微基准测试工具（Java Microbenchmarking Harness，JMH）可以产生不错的结果。
5. 分析与优化

   分析器（profiler）会收集各种信息，比如程序的哪些部分消耗内存，以及哪些方法消耗了最多的时间。一些分析器甚至会禁用垃圾收集器来帮助确定内存的分配模式。
   分析器对于检测程序中的线程死锁也很有用。
   Java开发工具包（JDK）附带了一个名为VisualVM的可视化分析器。
6. 样式检查

   比较流行的样式检查器是Checkstyle。
7. 静态错误分析

   尽管Java的静态类型检查会发现基本的语法错误，但额外的分析工具可以发现更复杂的错误，比如Findbugs工具。

## 九、文件
[Path接口](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/file/Path.html)代表一个文件或目录的路径，它是在不同的操作系统或文件系统之上的抽象。
```Java
// java.nio.file.Paths类包含了重载的static get()方法，用来获取Path对象
public final class Paths {
   public static Path get(String first, String... more); // 将一个路径字符串，或一个拼接成路径字符串的字符串序列，转换为Path对象
   public static Path get(URI uri); // 将给定URI转换为Path对象
}

// Path接口实现了Iterable<Path>接口，因此可以在for-in语句中遍历Path对象
public interface Path extends Comparable<Path>, Iterable<Path>, Watchable {
   ...
   Path relativize(Path other); // 在this路径和other路径之间，构造一个相对路径。可用于去掉基准路径
   default Path resolve(String other); // 在this路径后增加路径片段
   ...
}
```
[Files工具类](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/file/Files.html)中包含了一整套用于检查Path的各种信息的方法，也包含了方便读写文本文件和二进制文件的工具函数。

[WatchService](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/file/WatchService.html)能够设置一个进程，对某个目录中的变化做出反应。

为了查找文件，可以通过在FileSystem对象上调用getPathMatcher()来获得一个[PathMatcher](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/file/PathMatcher.html)，并传入模式：glob或regex。

## 十、字符串

1. 操作字符串
   - [String类](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/String.html)的对象是不可变的，每个看起来会修改String值的方法，实际上都创建并返回了一个全新的String对象。
   - Java 5引入了java.lang.StringBuilder类来构建字符串。在此之前，Java使用StringBuffer，它是线程安全的，因此成本也明显更高。
   - 在类的toString()方法中，不能直接将字符串与this拼接，会产生无限递归。

2. 格式化输出
   - Java 5引入的format()方法模仿了C语言的printf()方法，可用于PrintStream或PrintWriter对象，因此也可直接用于System.out。
   - String类也有一个静态的format()方法，它会产生一个格式化字符串。
   - Java中所有的格式化功能都由[java.util包里的Formatter类](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Formatter.html)处理。
   - 格式说明符：`%[argument_index$][flags][width][.precision]conversion`。
3. 文本块

   JDK 15添加了**文本块**，使用三引号来表示包含换行符的文本块。开头的"""后面的换行符会被自动去掉，块中的公共缩进也会被去掉。如果想要保留缩进，就移动最后的"""来产生所需的缩进。
4. 正则表达式

   可以使用[java.util.regex.Pattern类](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html)来创建正则表达式。

5. 扫描输入

   Java 5中添加的[Scanner类](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Scanner.html)减轻了扫描输入的负担。

## 十一、反射

反射：在运行时，发现和使用对象和类的类型信息。

程序中的每个类都有一个Class对象，它包含了与类有关的信息。

Java中有三种形式的反射：
   1. Class.forName("类名") / Object.getClass()
   2. 类名.class
   3. 对象 instanceof 类名 / Class.isInstance(对象)

Class类和java.lang.reflect库一起支持了反射，这个库里包含Field、Method以及Constructor类（每个都实现了Member接口）。可以使用Constructor来创建新的对象，使用get()和set()方法来读取和修改与Field对象关联的字段，使用invoke()方法调用与Method对象关联的方法。还可以调用getFields()、getMethods()和getConstructors()等方法，以返回表示字段、方法和构造器的对象数组。

## 十二、泛型

- 在类名或接口名后的尖括号内放置若干个类型参数，然后在使用该类或接口的时候再将其替换为实际的类型。
- 还可以对类内部的方法进行参数化，类自身是不是泛型的和是否存在参数化的方法无关。要定义一个泛型方法，需要将泛型参数列表放在返回值之前。
- 静态方法没有访问类的泛型类型参数的权限，因此如果要用到泛型能力，它就必须是泛型方法。
- 泛型方法和可变参数列表可以结合使用。
- 泛型代码内部并不存在有关泛型类型参数的可用信息。Java泛型是通过**类型擦除**实现的，泛型类型参数会被擦除为其非泛型上界。
- 类型擦除导致泛型代码无法用于需要显示引用运行时类型的操作，比如类型转换、instanceof操作，以及new表达式。可以通过引入**类型标签**(type tag)来补偿类型擦除导致的损失，意味着要在类型表达式中显示地为要使用的类型传入一个Class对象。
- 基类通配符允许读操作，超类通配符允许写操作，无界通配符表示某种具体类型。
- 泛型的限制：
   1. 基本类型不可作为类型参数。
   2. 一个类无法实现同一个泛型接口的两种变体。
   3. 对类型参数使用类型转换或instanceof是没有任何效果的。
   4. 不同的类型参数在重载时会产生相同类型的签名。
   5. 基类会劫持接口。
- catch子句无法捕获到泛型类型的异常，泛型类无法直接或间接地继承Throwable。但类型参数可以用于方法声明中的throws子句。

## 十三、枚举
1. 枚举类型的基本特性
   - 枚举类型的values()方法生成一个由枚举常量组成的数组，其中常量的顺序和常量声明的顺序保持一致。
   - 枚举实例的ordinal()方法返回代表其声明顺序的int值，getDeclaringClass()方法返回其所属的外部包装类，name()方法返回其被声明的名称，toString()方法同样也返回该名称。
   - Enum类的valueof()静态方法，根据传入的String，返回名称与该String匹配的枚举实例，如果匹配的实例不存在，则抛出异常。
   - 枚举类型需要通过`import static`静态导入。
   - 枚举类型继承自[java.lang.Enum](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Enum.html)，因此enum类不能再继承其他类，但**可以**实现一个或多个接口。
2. 在枚举类型中增加自定义方法
   ```Java
   public enum EnumExample {
      // 实例必须在方法和字段之前定义
      EXAMPLE_ONE("example one"),
      EXAMPLE_TWO("example two"),
      EXAMPLE_THREE("example three"); // 必须先用分号结束枚举实例的序列

      private String description;
      // 构造器的访问权限必须是包级或private
      private EnumExample(String description) {
         this.description = description;
      }
      public String getDescription() { return description; }
      // 重载枚举类型中的方法
      @Override public String toString() { return description.toLowerCase(); }
      // 甚至可以增加一个main()方法
      public static void main(String[] args) {
         EnumExample enumExample = EnumExample.EXAMPLE_ONE;
         // 在switch语句中使用枚举
         switch(enumExample) {
            // 在case语句中，无须使用枚举类型名来限定枚举实例
            case EXAMPLE_ONE:
               ...
               break;
            case EXAMPLE_TWO:
               ...
               break;
            case EXAMPLE_THREE:
               ...
               break;
            // 编译器不会因为没有default语句而报错，但如果此时在case语句中调用了return，编译器就会报错，即使覆盖了枚举中的所有值
         }
      }
   }
   ```
3. 组织枚举
   ```Java
   enum SecurityCategory {
      STOCK(Security.Stock.class),
      BOND(Security.Bond.class);
      Security[] values;
      SecurityCategory(Class<? extends Security> kind) {
         values = kind.getEnumConstants(); // Class的getEnumConstants()方法会返回该枚举类型的所有枚举实例。在非枚举类上调用该方法会返回null。
      }
      interface Security {
         enum Stock implements Security {
            SHORT, LONG, MARGIN
         }
         enum Bond implements Security {
            MUNICIPAL, JUNK
         }
      }
   }
   ```
4. [EnumSet](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/EnumSet.html)是与枚举类型一起使用的专用Set实现。
5. [EnumMap](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/EnumMap.html)是与枚举类型键一起使用的专用Map实现。
6. 常量特定方法
   - 可以在枚举类型中定义抽象方法，然后为每个枚举实例编写不同的实现，也可以直接重写常量特定方法，来赋予它们不同的行为。
   - 由于枚举实例是静态的，因此常量特定方法无法访问非静态域或方法。
   - 通过常量特定方法，可以用枚举实现职责链模式和状态机
7. 多路分发
   - 使用枚举类型分发
   - 使用常量特定方法
   - 使用EnumMap分发
   - 使用二维数组
8. 模式匹配
   1. 新特性
      - switch中的箭头语法
      - switch中的case null
      - 将switch作为表达式
      - 智能转型：`x instanceof String s`
   2. 违反里氏替换原则
   3. 守卫
   4. 支配性
   5. 覆盖范围

## 十四、克隆对象

浅拷贝：只拷贝对象引用。

深拷贝：实际对象的组成部分包括该对象引用、该引用指向的所有对象，以及所有**这些**对象所指向的所有对象，创建所有这些内容的完整副本，称为**深拷贝**。

1. 为类增加可克隆能力
   - 基类Object中的clone()方法是protected的，它会执行实际**子类对象**的按位复制，它还会验证一个类是否实现了Cloneable接口（一个空（标记）接口），如果没有，便会抛出CloneNotSupportedException异常。
   - 为类增加可克隆能力的步骤如下：
      - 实现Cloneable接口
      - 重写clone()方法
      - 在clone()方法中调用super.clone()方法
      - 在clone()方法中捕获异常
      - 将clone()方法设为public的
   - 因为在Java中不能在派生过程中缩小方法的访问权限，一旦一个类成为可克隆的，一切从其派生的类就都是可克隆的。
   - 克隆组合对象时，需要按顺序对所有成员对象执行深拷贝。
2. 不可变类
   1. 创建不可变类：定义一个类，可以读取内部状态，但看似会修改内部状态的方法只是创建了一个新的对象。
   2. 不可变的缺点：创建新对象的开销较大。解决办法是创建一个可以被修改的伴生类，要做很多修改工作时切换使用该伴生类，并在完成后切换回不可变类。
   3. String本质上是不可变的。

## 十五、注解

1. 基本语法

   注解的语法主要是在语言中添加@符号。
   1. 定义注解
      ```Java
      import java.lang.annotation.*;

      // 注解的定义要求必须有元注解
      @Target(ElementType.METHOD)
      @Retention(RetentionPolicy.RUNTIME)
      public @interface UseCase { // 除了@符号，注解的定义和接口非常像
         // 注解可以包含一些可以设定值的元素，元素看起来比较像接口方法
         int id();
         String description() default "no description"; // 可以为元素指定默认值

         // 没有任何元素的注解称为标记注解
      }

      public class PasswordUtils {
         // 注解元素定义值的方式，在注解声明后的圆括号中，用“名-值”对形式来表示
         @UseCase(id = 47, description = "Passwords must contain at least one numeric")
         public boolean validatePassword(String passwd) {
            return passwd.matches("\\w*\\d\\w*");
         }

         // 未给注解元素传入值时，注解定义中的默认值便会作为注解元素的当前值
         @UseCase(id = 48)
         public String encryptPassword(String passwd) {
            return new StringBuilder(passwd).reverse().toString();
         }
      }
      ```
      如果注解元素的名称为value，那么只要它是唯一指定的元素类型，就无须使用“名-值”对的语法，直接在圆括号内指定该值即可
      1. 注解所允许的元素类型：
         - 所有的基本类型（int、float、boolean等）
         - String（字符串）
         - Class（类）
         - enum（枚举）
         - Annotation（注解）
         - 以上任何类型的数组
      2. 默认值的限制
         - 注解元素要么有默认值，要么由使用该注解的类来设定值。
         - 任何非基本类型元素都不能赋值为null，可以通过检查该元素是否为特殊值（如空字符串或负值）来判断某个元素存在与否。
      3. 注解不支持继承
   2. 标准注解
      - @Override：用来声明该方法的定义会重写基类的某个方法。
      - @Deprecated：如果该元素被使用了，则编译器会发出警告。
      - @SuppressWarning：关闭不当的编译警告。
      - @SafeVarargs：在使用泛型作为可变参数的方法或构造器中关闭对调用者的警告。
      - @FunctionalInterface：表明类型声明是函数式接口。
   3. 元注解

      |    注解    |     效果     |
      |:----------|:-------------|
      |@Target|该注解可应用的地方。可能的ElementType参数包括：CONSTRUCTOR——构造器声明；FIELD——字段声明（包括枚举常量）；LOCAL_VARIABLE——本地变量声明；METHOD——方法声明；PACKAGE——包声明；PARAMETRE——参数声明；TYPE——类、接口（包括注解类型）或枚举的声明|
      |@Retention|注解信息可以保存多久。可能的RetentionPolicy参数包括：SOURCE——注解会被编译器丢弃；CLASS——注解在类文件中可被编译器使用，但会被虚拟机丢弃；RUNTIME——注解在运行时仍被虚拟机保留，可以通过反射读取到注解信息|
      |@Documented|在Javadoc中引入该注解|
      |@Inherited|允许子类继承父注解|
      |@Repeatable|可以多次应用于同一个声明|
2. 用javac处理注解

   通过javac可以创建编译时注解处理器，并将注解应用于Java源文件。处理注解时可以创建新的源文件，并在新一轮处理中会检查该源文件自身的注解。
   ```Java
   // 指定本注解处理器可以处理哪些注解
   @SupportedAnnotationTypes("annotations.UseCase")
   // 指定本注解处理器可以支持哪些Java版本
   @SupportedSourceVersion(SourceVersion.RELEASE_8)
   public class UseCaseProcessor extends AbstractProcessor {
      // 唯一需要重写的方法
      @Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
         ...
      }
   }
   ```
   编译命令：`javac -processor annotations.UseCaseProcessor PasswordUtils.java`。

## 十六、Java I/O系统

1. I/O 流

   概念：
      - InputStream和OutputStream类提供了基于字节的I/O能力。
      - Reader和Writer类提供了兼容Unicode并且基于字符的I/O能力。
      - InputStreamReader可以将InputStream转换为Reader，OutputStreamWriter可以将OutputStream转换为Writer。

   1. [InputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/InputStream.html)和[Reader](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/Reader.html)类型

      | InputStream类 | Reader类 |  功能  |
      |:--|:-------|:-----------|
      |[ByteArrayInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/ByteArrayInputStream.html)|[CharArrayReader](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/CharArrayReader.html)|使内存中的缓存区可以充当InputStream/Reader|
      |[StringBufferInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/StringBufferInputStream.html)(已弃用)|[StringReader](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/StringReader.html)|将字符串转换为InputStream/Reader|
      |[FileInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/FileInputStream.html)|[FileReader](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/FileReader.html)|用于从文件中读取信息|
      |[PipedInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/PipedInputStream.html)|[PipedReader](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/PipedReader.html)|用于生成写入到对应的PipedOutputStream/PipedReader中的数据。它实现了“管道传输”的概念|
      |[SequenceInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/SequenceInputStream.html)|（没有对应的类）|将两个以上的InputStream转换为单个InputStream|
      |[FilterInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/FilterInputStream.html)|[FilterReader](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/FilterReader.html)|作为装饰器接口的抽象类，装饰器用来为其他InputStream/Reader类提供有用的功能|
   2. [OutputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/OutputStream.html)和[Writer](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/Writer.html)类型

      | OutputStream类 | Writer类 |  功能  |
      |:---|:------|:-------------|
      |[ByteArrayOutputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/ByteArrayOutputStream.html)|[CharArrayWriter](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/CharArrayWriter.html)|使内存中的缓存区可以充当OutputStream/Writer|
      |（没有对应的类）|[StringWriter](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/StringWriter.html)|用于向字符串中写入信息|
      |[FileOutputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/FileOutputStream.html)|[FileWriter](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/FileWriter.html)|用于向文件中写入信息|
      |[PipedOutputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/PipedOutputStream.html)|[PipedWriter](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/PipedWriter.html)|向其中写入的任何信息都将自动作为对应的PipedInputStream/PipedWriter的输入。实现了“管道传输”的概念|
      |[FilterOutputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/FilterOutputStream.html)|[FilterWriter](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/FilterWriter.html)（没有任何子类的抽象类）|作为装饰器接口的抽象类，装饰器用来为其他OutputStream/Writer类提供有用的功能|

   3. 添加属性和有用的接口
      1. FilterInputStream和FilterReader类型

         | FilterInputStream类 | FilterReader类|  功能  |
         |:---|:-------|:-------------------------|
         |[DataInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/DataInputStream.html)|（没有对应的类）|与DataOutputStream配合使用，以可移植的方式从流中读取基本类型|
         |[BufferedInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/BufferedInputStream.html)|[BufferedReader](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/BufferedReader.html)|用于防止在每次需要更多数据时都发生物理读操作|
         |[LineNumberInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/LineNumberInputStream.html)（已弃用）|[LineNumberReader](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/LineNumberReader.html)|记录输入流中的行号|
         |[PushbackInputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/PushbackInputStream.html)|[PushbackReader](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/PushbackReader.html)|包含一个单字节回退缓冲区，用于将最后读取的字符推回输入流|
      2. FilterOutputStream和FilterWriter类型

         | FilterOutputStream类 | FilterWriter类 |  功能  |
         |:---|:-------|:--------------------|
         |[DataOutputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/DataOutputStream.html)|（没有对应的类）|与DataInputStream配合使用，以可移植的方式向流中写入基本类型|
         |[PrintStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/PrintStream.html)|[PrintWriter](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/PrintWriter.html)|用于生成格式化的输出|
         |[BufferedOutputStream](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/BufferedOutputStream.html)|[BufferedWriter](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/BufferedWriter.html)|用于防止在每次发送数据时都发生物理写操作|
   4. RandomAccessFile

      [RandomAccessFile](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/io/RandomAccessFile.html)适合用来处理由大小已知的记录组成的文件。
2. 标准I/O
   1. System.in是原生InputStream对象，System.out和System.err都是PrintStream对象。
   2. 标准I/O重定向
      ```Java
      // Java的System类有静态方法对标准I/O流进行重定向
      public final class System {
         ...
         public static void setIn(InputStream in);
         public static void setOut(PrintStream out);
         public static void setErr(PrintStream err);
         ...
      }
      ```
   3. 进程控制

      [ProcessBuilder](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/ProcessBuilder.html)可用于构造进程，然后通过`start()`启动，得到[Process](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Process.html)，Process提供了捕获流的方法。
3. 新I/O系统
   1. 通道

      有三个类可以生成[FileChannel](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/channels/FileChannel.html#tryLock())：FileInputStream、FileOutputStream、RandomAccessFile。
   2. 缓冲区

      ByteBuffer（即保存原生字节的缓冲区）是唯一直接和通道通信的类型。

      - [ByteBuffer](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/ByteBuffer.html)：字节缓冲区
      - [CharBuffer](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/CharBuffer.html)：字符缓冲区
      - [DoubleBuffer](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/DoubleBuffer.html)：双精度浮点数缓冲区
      - [FloatBuffer](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/FloatBuffer.html)：单精度浮点数缓冲区
      - [IntBuffer](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/IntBuffer.html)：整型缓冲区
      - [LongBuffer](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/LongBuffer.html)：长整型缓冲区
      - [ShortBuffer](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/ShortBuffer.html)：短整型缓冲区
   3. 内存映射文件
      - 内存映射文件（Memory-mapped file）可以创建和修改那些因为太大而无法加载到内存中的文件。
      - 先通过RandomAccessFile为该文件生成管道，然后调用map()生成[MappedByteBuffer](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/MappedByteBuffer.html)。
   4. 文件加锁
      ```Java
      public abstract class FileChannel extends AbstractInterruptibleChannel implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel {
         ...
         public final FileLock lock() throws IOException;
         public abstract FileLock lock(long position, long size, boolean shared) throws IOException;
         public final FileLock tryLock() throws IOException;
         public abstract FileLock tryLock(long position, long size, boolean shared) throws IOException;
         ...
      }
      ```

   ![nio类之间的关系]({{ page.img_url }}/nio类之间的关系.jpg)

## 十七、Javadoc

[Javadoc工具](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html)可以提取注释并输出为HTML文件，该工具可通过安装JDK获得。

1. 语法

   所有的Javadoc指令都出现在以`/**`开头的注释内（但仍然以`*/`结束）。一共有三种类型的注释文档，分别对应于注释前面的元素：类、字段或方法。Javadoc只会为有public和protected权限的成员处理注释文档。

2. 嵌入式HTML

   Javadoc会将HTML代码原样传给生成的HTML文档。

3. 部分示例标签

   doc标签都以@开头。**独立doc标签**放在一行的注释的开头，**行内doc标签**可以出现在Javadoc注释内的任何地方，但必须用花括号包围起来。
   1. @see：引用其他类中的文档。
   2. {@link *package.class#member label*}：引用文档，使用label作为超链接文本
   3. {@docRoot}：生成相对文档根目录的相对路径。
   4. {@inheritDoc}：将文档从当前类最近的基类继承到当前的文档注释中。
   5. @version：版本信息。
   6. @author：作者信息。
   7. @since：记录本代码是从哪个版本开始使用某个特定功能。
   8. @param：描述方法参数。
   9. @return：描述返回值。
   10. @throws：描述异常。
   11. @deprecated：表示该功能已被弃用。

## 十八、equals()和hashCode()

Object类中的equals()方法默认比较内存地址，hashCode()方法默认使用内存地址生成哈希码。

```Java
// 在基类和派生类中equals()和hashCode()的推荐写法

public class BaseClass {
   private int value;
   
   public BaseClass(int i) {
      value = i;
   }

   @Override
   public boolean equals(Object rval) {
      return rval instanceof BaseClass &&
         Objects.equals(value, ((BaseClass)rval).value);
   }

   @Override
   public int hashcode() {
      return Objects.hashcode(value);
   }
}

public class DerivedClass extends BaseClass {
   private OtherClass other;

   public DerivedClass(int i, OtherClass o) {
      super(i);
      other = o;
   }

   @Override
   public boolean equals(Object rval) {
      return rval instanceof DerivedClass &&
         super.equals(rval) &&
         Objects.equals(other, ((DerivedClass)rval).other);
   }

   @Override
   public int hashcode() {
      return Objects.hash(other, (BaseClass)this); // 不确定这样写是否正确
   }
}
```

## 自动内存管理

1. Java内存区域与内存溢出异常
   1. 运行时数据区域
      ![Java虚拟机运行时数据区]({{ page.img_url }}/20220805103117.png)
      1. 程序计数器(Program Counter Register)：当前线程所执行的字节码的行号指示器，每条线程都需要有一个独立的程序计数器，这是线程私有的内存。
      2. Java虚拟机栈(Java Virtual Machine Stack)：这是线程私有的内存。每个Java方法被调用的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
      3. 本地方法栈(Native Method Stacks)：与虚拟机栈发挥的作用非常相似，只不过是为虚拟机使用到的本地(Native)方法服务。
      4. Java堆(Java Heap)：被所有线程共享的一块内存区域，“几乎”所有的Java对象实例都在这里分配内存。由于即时编译技术和逃逸分析技术的进步，栈上分配、标量替换优化手段的出现，以及日后可能出现值类型的支持，Java对象实例不再是绝对都分配在堆上。
      5. 方法区(Method Area)：被所有线程共享的一块内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
         运行时常量池是方法区的一部分，用于存放类在编译器生成的各种字面量与符号引用，以及由符号引用翻译出来的直接引用。
   2. HotSpot虚拟机Java堆中的对象
      1. 对象的创建
         1. 检查对应的类是否已被加载、解析和初始化过，如果没有，就执行相应的类加载过程；
         2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存；
         3. 内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值；
         4. 虚拟机对对象头进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息；
         5. 最后执行\<init\>()方法，按照程序员的意愿对对象进行初始化。
      2. 对象的内存布局
         1. 对象头(Header)：第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；第二类是类型指针，指向对象的类型元数据的指针，但并不是所有的虚拟机实现都在对象头上保留类型指针。
         2. 实例数据(Instance Data)：从父类继承下来的，和在子类中定义的各种类型的字段内容。
         3. 对齐填充(Padding)：对象起始地址必须是8字节的整数倍。
      3. 对象的访问定位：主流的访问方式主要有使用句柄和直接指针两种。

## 垃圾收集算法

1. 可达性分析算法：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。
   在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：
   - 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
   - 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
   - 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
   - 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
   - Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryException）等，还有系统类加载器。
   - 所有被同步锁（synchronized关键字）持有的对象。
   - 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
2. 分代收集理论：一套符合大多数程序运行实际情况的经验法则，它建立在三个分代假说上：
   1. 弱分代假说：绝大多数对象都是朝生夕灭。
   2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。
   3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。
3. 垃圾收集算法
   1. 标记——清除算法：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。
      主要缺点：
      1. 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；
      2. 内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
   2. 标记——复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉。
      如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。
      这种复制回收算法的代价是将可用内存缩小为了原来的一半。一般用于新生代的回收。
   3. 标记——整理算法：首先标记出所有存活的对象，然后让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
      不移动对象垃圾收集的停顿时间会更短，但内存分配时会更复杂；移动对象则内存回收时会更复杂，但能提高整个程序的吞吐量。
4. HotSpot的算法细节实现
   1. 根节点枚举：使用一组OopMap的数据结构来直接得到哪些地方存放着对象引用。
   2. 安全点：只是为特定的指令生成了OopMap，这些位置被称为安全点。
   3. 安全区域：能够确保在某一段代码片段之中，引用关系不会发生变化。
   4. 记忆集与卡表：记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。当记录精度为“卡精度”时，每个记录精确到一块内存区域，该区域内有对象含有跨代指针，也即是用“卡表”(Card Table)去实现记忆集。
   5. 写屏障：在引用对象赋值时会产生一个环形通知，供程序执行额外的动作。
   6. 并发的可达性分析：为解决并发扫描时的对象消失问题，有两种解决方案：增量更新和原始快照。增量更新会记录新插入的黑色对象指向白色对象的引用关系，原始快照会记录删除的灰色对象指向白色对象的引用关系，在并发扫描结束后，再重新扫描一次这些记录的引用关系。
5. 垃圾收集器
   1. Serial收集器：HotSpot虚拟机运行在客户端模式下的默认新生代收集器。采用标记——复制算法回收新生代，进行垃圾收集时，必须暂停其他所有工作，直到它收集结束。额外内存消耗最小，单线程收集效率最高。
   2. ParNew收集器：Serial收集器的多线程并行版本，唯一一款能和CMS收集器配合工作的新生代收集器。
   3. Parallel Scavenge收集器：和ParNew收集器非常相似，但其目标是达到一个可控制的吞吐量。
   4. Serial Old收集器：Serial收集器的老年代版本，基于标记——整理算法实现的老年代收集器。
   5. Parallel Old收集器：Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记——整理算法实现。
   6. CMS收集器：一种以获取最短回收停顿时间为目标的基于标记——清除算法实现的老年代收集器。运作过程分为四个步骤：初始标记、并发标记、重新标记(增量更新)、并发清除。
      缺点：对处理器资源非常敏感；无法处理“浮动垃圾”，有可能出现“并发失败”进而导致另一次完全“Stop The World”的Full GC的产生；收集结束时会有大量空间碎片产生。
   7. Garbage First收集器：把连续的Java堆划分为多个大小相等的独立区域（Region），G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值收益最大的那些Region。运作过程分为四个步骤：初始标记、并发标记、最终标记(原始快照)、筛选回收。
   8. Shenandoah收集器：支持并发的整理算法(读屏障和转发指针)、默认不使用分代收集、用“连接矩阵”的全局数据结构来记录跨Region的引用关系。
   9. ZGC收集器：一款基于Region内存布局的，(暂时)不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记——整理算法的，以低延迟为首要目标的垃圾收集器。

   HotSpot虚拟机运行在客户端模式下的默认垃圾收集器是Serial收集器和Serial Old收集器，运行在服务端模式下默认垃圾收集器在JDK8及以前是Parallel Scavenge收集器和Parallel Old收集器，在JDK9及以后是G1收集器。
   各款垃圾收集器的并发情况：
   ![各款垃圾收集器的并发情况]({{ page.img_url }}/20220806092811.png)

## 类文件结构

Class文件是一组以8个字节为基础单位的二进制流，只有两种数据类型：“无符号数”和“表”，表是由多个无符号数或者其他表作为数据项构成的复合数据类型。Class文件格式如下所示：

| 类型 |  名称  |   数量   |
|:----|:------|:---------|
|  u4  | magic |   1   |
|  u2  |minor_version| 1 |
|  u2  |major_version| 1 |
|  u2  |constant_pool_count| 1 |
|cp_info|constant_pool|constant_pool_count-1|
|  u2  |access_flags| 1 |
|  u2  |this_class| 1 |
|  u2  |super_class| 1 |
|  u2  |interfaces_count| 1 |
|  u2  |interfaces|interfaces_count|
|  u2  |fields_count| 1 |
|field_info|fields|fields_count|
|  u2  |methods_count| 1 |
|method_info|methods|methods_count|
|  u2  |attributes_count| 1 |
|attribute_info|attributes|attributes_count|

1. Class类文件的结构：
   1. 魔数(0xCAFFBABE)与Class文件的版本(次版本号与主版本号)
   2. 常量池
   3. 访问标志
   4. 类索引、父类索引与接口索引集合
   5. 字段表集合
   6. 方法表集合
   7. 属性表集合：Code(Java代码编译成的字节码指令)、ConstantValue(由final关键字定义的常量值)、Deprecated(被声明为deprecated的方法和字段)和Exceptions(方法抛出的异常列表)等。

   其中字段表与方法表的结构都如下：
   
   | 类型 | 名称 | 数量 |
   |:----|:-----|:-----|
   |  u2  |access_flags| 1 |
   |  u2  |name_index| 1 |
   |  u2  |descriptor_index| 1 |
   |  u2  |attributes_count| 1 |
   |attribute_info|attributes|attributes_count|

2. 字节码指令：由一个字节长度的操作码(Opcode)以及跟随其后的零至多个操作数(Operand)构成。包括：加载和存储指令、运算指令、类型转换指令、对象创建与访问指令、操作数栈管理指令、控制转移指令、方法调用和返回指令、异常处理指令和同步指令。

## 虚拟机类加载机制

类的声明周期：
![类的生命周期]({{ page.img_url }}/20220807171443.png)

1. 类加载的过程
   1. 加载
      1. 通过一个类的全限定名来获取定义此类的二进制字节流；
      2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
      3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
   2. 验证：确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。
      1. 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
      2. 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。
      3. 字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
      4. 符号引用验证：对类自身以外的各类信息进行匹配性校验，判断该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。
   3. 准备：正式为类中定义的变量(即静态变量)分配内存并设置初始值。
   4. 解析：将常量池内的符号引用替换为直接引用。
   5. 初始化：执行类构造器\<clinit\>方法。\<clinit\>方法是由编译器自动按照定义顺序收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。
2. 类加载器
   1. 双亲委派模型：除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。类加载器之间的父子关系一般不是以继承的关系来实现的，通常使用组合关系来复用父加载器的代码。
      工作过程：一个类加载器收到类加载的请求后，它首先把这个请求委派给父类加载器去完成，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。
      好处：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，双亲委派模型能够保证无论哪一个类加载器要加载某个类，最终都是委派给一个相对应的类加载器加载。
   2. JDK 8及之前版本
      类加载器双亲委派模型：
      ![类加载器双亲委派模型]({{ page.img_url }}/20220807205324.png)
   3. JDK 9及之后版本
      类加载器双亲委派模型：
      ![类加载器双亲委派模型]({{ page.img_url }}/20220807205550.png)

## 虚拟机字节码执行引擎

1. 运行时栈帧结构：Java虚拟机以方法作为最基本的执行单元，“栈帧”则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。
   1. 局部变量表：一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
   2. 操作数栈：用于存放字节码指令中涉及的操作数。
   3. 动态连接：指向运行时常量池中该栈帧所属方法的引用。
   4. 方法返回地址：主调方法的PC计数器的值。
2. 方法调用：确定被调用方法的版本。
   1. 解析：静态方法、私有方法、实例构造器、父类方法，再加上被final修饰的方法，这5种方法调用会在类加载时就把符号引用解析为该方法的直接引用。
   2. 分派
      1. 静态分派：依赖静态类型来决定方法执行版本的分派动作。典型应用表现是方法重载。
      2. 动态分派：根据实际类型来决定方法执行版本的分派动作。典型应用表现是方法重写。
      3. 单分派和多分派：方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。如今的Java语言是一门静态多分派、动态单分派的语言。
      4. 虚拟机动态分派的实现：为类型在方法区中建立一个虚方法表。
3. 基于栈的字节码解释执行引擎
   编译过程：
      ![编译过程]({{ page.img_url }}/20220810221529.png)
   Javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构，里面的指令大部分是零地址指令，它们依赖操作数栈进行工作。
   基于栈的指令集的优缺点：
      - 优点：可移植、代码相对紧凑、编译器实现更加简单等。
      - 缺点：理论上执行速度会更慢(由于指令数量和内存访问的原因)。

## 前端编译与优化

1. 编译过程
   ![Javac的编译过程]({{ page.img_url }}/20220813195825.png)
   1. 准备过程：初始化插入式注解处理器。
   2. 解析与填充符号表
      - 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。
      - 填充符号表。产生符号地址和符号信息。
   3. 插入式注解处理器的注解处理
   4. 语义分析与字节码生成过程
      - 标注检查。对语法的静态信息进行检查。
      - 数据流及控制流分析。对程序动态运行过程进行检查。
      - 解语法糖。将简化代码编写的语法糖还原为原有的形式。
      - 字节码生成。将前面各个步骤所生成的信息转化为字节码。
2. Java语法糖
   1. 泛型：本质是参数化类型或者参数化多态的应用，即可以将操作的数据类型指定为签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。
      实现方式：类型擦除。在编译时将参数类型擦除，将泛型类型都变回裸类型，只在元素访问、修改时自动插入一些强制类型转换和检查指令。
      缺陷：
         1. 无法支持原生类型的泛型。
         2. 运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦。
         3. 丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况。例如类型擦除会把方法的特征签名变得一模一样，导致无法重载，但将方法的返回类型改变后又可以重载。
   2. 自动装箱、拆箱与遍历循环
   3. 条件编译：条件为常量的if语句。

## 后端编译与优化

1. 即时编译器
   1. 编译层次
   2. 编译对象与触发条件
      1. 编译对象：被多次调用的方法、被多次执行的循环体。
      2. 热点探测判定方法
         - 基于采样的热点探测
         - 基于计数器的热点探测
   3. 编译过程
      ![Client Compiler架构]({{ page.img_url }}/20220813202527.png)
2. 提前编译器
3. 编译器优化技术
   1. 方法内联：把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用。
   2. 逃逸分析
   3. 公共子表达式消除：如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式，只需要直接用前面计算过的表达式结果代替E。
   4. 数组边界检查消除

## Java内存模型与线程

1. Java内存模型
   1. 主内存与工作内存：所有的变量都存储在主内存中，每条线程有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本。线程对变量的所有操作都只能在自己的工作内存中进行，不能直接读写主内存中的数据。线程间变量值的传递需要通过主内存进行。
      ![线程、主内存、工作内存三者的交互关系]({{ page.img_url }}/20220812102812.png)
   2. 内存间交互操作：关于主内存与工作内存之间具体的交互协议，Java内存模型中定义了8种原子操作来完成：
      - lock(锁定)
      - unlock(解锁)
      - read(读取)
      - load(载入)
      - use(使用)
      - assign(赋值)
      - store(存储)
      - write(写入)
   3. volatile型变量的语义：1、保证此变量对所有线程的可见性；2、禁止指令重排序优化。
2. Java线程
      1. 实现：每一个Java线程都是直接映射到一个操作系统内核线程来实现的，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
      2. 状态
         Java语言定义了6种线程状态：
            - 新建(New)
            - 运行(Runnable)
            - 无限期等待(Waiting)
            - 限期等待(Timed Waiting)
            - 阻塞(Blocked)
            - 结束(Terminated)

         上述6种状态的转换关系如下图所示：
            ![线程状态转换关系]({{ page.img_url }}/20220812104642.png)

## 线程安全与锁优化

1. 线程安全
   1. 实现方法
      1. 互斥同步：临界区、互斥量、信号量。
      2. 非阻塞同步：基于冲突检测的乐观并发策略。
      3. 无同步方案：可重入代码、线程本地存储。
2. 锁优化
   1. 自旋锁与自适应自旋
      - 自旋锁：当锁被某个线程持有时，让后面请求锁的线程执行一个忙循环(自旋)，看看持有锁的线程是否很快就会释放锁。
      - 自适应自旋：由前一次在同一个锁上的自旋时间及锁的拥有者的状态，来决定自旋的时间。
   2. 锁消除：虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。
   3. 锁粗化：如果虚拟机探测到一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。
   4. 轻量级锁
      对象的对象头在不同状态下的存储内容如下表所示：
         ![对象头Mark Word]({{ page.img_url }}/20220812110629.png)
      工作过程：
         - 加锁
         - 解锁
   5. 偏向锁
      偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示：
         ![偏向锁、轻量级锁的状态转化及对象Mark Word的关系]({{ page.img_url }}/20220812111042.png)
