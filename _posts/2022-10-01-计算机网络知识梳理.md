---
categories: [知识梳理]
---
# 计算机网络知识梳理

## 一、应用层

1. HTTP（HyperText Transfer Protocol，超文本传输协议）
   1. 交互过程：
      1. HTTP客户进程发起一个到服务器80端口的TCP连接，该端口号是HTTP的默认端口。在客户和服务器上分别有一个套接字与该连接相关联。
      2. HTTP客户经它的套接字向该服务器发送一个HTTP请求报文。
      3. HTTP服务器进程经它的套接字接收该请求报文，然后从其存储器中检索对象或执行后端业务逻辑，在一个HTTP响应报文中封装对象，并通过其套接字向客户发送响应报文。
      4. HTTP服务器进程通知TCP断开该TCP连接。
      5. HTTP客户接收响应报文，TCP连接关闭。
   2. 报文格式：
       - 请求报文

         ![HTTP请求报文的格式](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220616082819.png)
       - 响应报文

         ![HTTP响应报文的格式](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220616082908.png)
   3. 版本：
      1. HTTP/0.9
      只支持GET请求方式。
      1. HTTP/1.0
         - 短连接：每发送一个HTTP请求都需要建立一个TCP连接；
         - 请求方法：新增了POST、PUT、DELETE、HEAD等请求方法；
         - 请求头和响应头：增加了请求头和响应头的概念，能在通讯中指定版本号，以及传输一些其他的元信息（如状态码、权限、缓存和内容编码等）。
      2. HTTP/1.1
         - 长连接：在请求头中新增connection字段，默认设置为keep-alive即采用长连接，在一个TCP连接上可以发送多个HTTP请求；
         - 缓存处理：引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略；
         - 带宽优化及网络连接的使用：在请求头引入了range字段，允许只请求资源的某个部分，返回码是206（Partial Content），支持断点续传功能；
         - 错误通知的管理：新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除；
         - 互联网地址的维护：请求头和响应头都支持host字段，允许多个主机名共享一个IP地址，也即一台服务器可以服务多个网站。
      3. HTTP/2
         - 二进制分帧：在应用层和传输层增加了二进制分帧层，将传输的信息分割为更小的消息和帧（frame）,并采用二进制编码；
         - 多路复用：把每个请求当做一个流，请求数据和响应数据分成多个帧，帧里的stream identifier标明该帧所属的流，一个HTTP/2可以承载数十至数百个流的复用；
         - 请求优先级：允许给每个请求设置优先级，避免多路复用导致关键请求被阻塞；
         - 头部压缩：引入了HPACK算法，用于对HTTP头部做压缩。其原理在于：客户端与服务端维护一份共同的静态字典（Static Table），其中包含了常见头部名及常见头部名与值的组合；客户端和服务端根据先入先出的原则，维护一份可动态添加内容的共同动态字典（Dynamic Table）；客户端和服务端支持基于该静态哈夫曼码表的哈夫曼编码（Huffman Coding）；
         - 服务端推送：服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。
      4. HTTP/3
         之前HTTP协议的缺点：
            - HTTP协议在传输层使用了TCP进行报文传输，而且HTTPS、HTTP/2还采用了TLS协议进行加密，这样就会导致三次握手的连接延迟：即TCP三次握手（一次）和TLS握手（两次），如下图所示：

               ![HTTPS连接](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220721111609.png)
            - TCP的主要作用是以正确的顺序将整个字节流从一个端点传输到另一个端点，但是当流中的某些数据包丢失时，TCP需要重新发送这些丢失的数据包，等到丢失的数据包到达对应端点时才能够被HTTP处理，这被称为TCP队头阻塞问题。
         QUIC协议：Google提出来的一个基于UDP的传输协议，所以QUIC又被叫做快速UDP互联网连接。
            - QUIC的握手连接更快，因为它使用了UDP作为传输层协议，这样能够减少三次握手的时间延迟。而且QUIC的加密协议采用了TLS协议的最新版本TLS 1.3，相对之前的TLS 1.1-1.2，TLS1.3允许客户端无需等待TLS握手完成就开始发送应用程序数据的操作，可以支持1 RTT和 0 RTT，从而达到快速建立连接的效果。
            - QUIC使用的stream之间是相互隔离的，不会阻塞其他stream数据的处理，所以使用UDP并不会造成队头阻塞。
            - QUIC使用了Packet Number，不管服务器有没有接收到数据包，这个Packet Number都会 +1。QUIC引入了一个stream offset的概念，一个stream可以传输多个stream offset，每个stream offset其实就是一个PN标识的数据，即使某个PN标识的数据丢失，PN + 1后，它重传的仍旧是PN所标识的数据，等到所有PN标识的数据发送到服务器，会按照顺序进行组装，保证了可靠性。
            - TCP协议头部没有经过加密和认证，所以在传输的过程中很可能被篡改，与之不同的是，QUIC中的报文头部都是经过认证，报文也经过加密处理。这样只要对QUIC的报文有任何修改，接收端都能够及时发现，保证了安全性。
            - 手机或者移动设备在4G信号下和WiFi等网络情况下切换，不会断线重连，用户甚至无任何感知，能够直接实现平滑的信号切换。
   4. cookie：用户唯一识别码
      1. Web站点产生一个唯一识别码，并以此作为索引在后端数据库中产生一个表项。
      2. 服务器用一个包含Set-cookie：首部的HTTP响应报文对客户进行响应，其中Set-cookie：首部含有该识别码。
      3. 客户在它的cookie文件中添加一行，该行包含服务器的主机名和在Set-cookie：首部中的识别码。
      4. 客户浏览Web站点时，每请求一个Web页面，都会查询该cookie文件并抽取它对这个网站的识别码，并放到HTTP请求报文的cookie首部中。
      5. 服务器解析cookie首部中的识别码，查询后端数据库中的表项，就能跟踪用户在Web站点的活动。
   5. session
      1. 产生sessionID：session是基于cookie的一种方案，所以，首先要产生cookie。client第一次访问server，server生成一个随机数，命名为sessionID，并将其放在响应头里，以cookie的形式返回给client，client以处理其他cookie的方式处理这段 cookie。
      2. 保存sessionID：server 将要保存的数据保存在相对应的sessionID之下，再将sessionID保存到服务器端的特定的保存session的内存中（如一个叫 session的哈希表）。
      3. 使用session：client再次访问server，会带上首次访问时获得的值为sessionID的cookie，server读取cookie中的sessionID，根据sessionID到保存session的内存寻找与sessionID匹配的数据，若寻找成功就将数据返回给client。
      4. 和cookie的区别：
         1. session在服务器端，cookie在客户端。
         2. session用户无法查看和修改，cookie用户可以查看修改。
         3. session和cookie 的存储容量不同。
         4. session的实现依赖于sessionID，而sessionID又存储在cookie上，所以，可以这么说：session是基于cookie实现的一种数据存储方式。
   6. 状态码

      HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。

      |分类|分类描述|
      |:--:|:------|
      |1xx|信息，服务器收到请求，需要请求者继续执行操作|
      |2xx|成功，操作被成功接收并处理|
      |3xx|重定向，需要进一步的操作以完成请求|
      |4xx|客户端错误，请求包含语法错误或无法完成请求|
      |5xx|服务器错误，服务器在处理请求的过程中发生了错误|
      
      常用状态码：

      |状态码|状态码英文名称|中文描述|
      |:---:|:-----------|:--------|
      |100|Continue|继续。客户端继续其请求|
      |200|OK|请求成功。一般用于GET和POST请求|
      |301|Moved Permanently|永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI|
      |302|Found|临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI|
      |400|Bad Request|客户端请求的语法错误，服务器无法理解|
      |404|Not Found|服务器无法根据客户端的请求找到资源（网页）|
      |500|Internal Server Error|服务器内部错误，无法完成请求|
      |502|Bad Gateway|作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|
   7. GET和POST的区别
      1. 在HTTP协议的语义中，GET用来查询资源，POST用来新增资源。两者在请求报文的请求行中的方法字段不同。
      2. 在HTTP协议的规范中，GET请求携带的数据以参数的形式附加在url后，POST请求携带的数据放在request body中。浏览器一般对url的长度有限制，使得GET请求的携带的数据不能过多。GET请求也可以在request body中携带数据，但不能保证服务端一定会处理。
      3. 在HTTP协议的语义中，GET是幂等的，而POST不是。因此代理服务器和浏览器可以缓存GET请求，但不可以缓存POST请求。浏览器可以将GET请求存为书签，历史记录中保存了GET请求的所有参数。
2. 电子邮件
   1. 简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）
   2. 邮件访问协议
      1. 第三版的邮局协议（Post Office Protocol——Version 3，POP3）
      2. 因特网邮件访问协议（Internet Mail Access Protocol，IMAP）
   3. 传输过程：
      1. 发送方代理使用SMTP将邮件发送到发送方邮件服务器；
      2. 发送方邮件服务器使用SMTP将邮件发送到接收方邮件服务器；
      3. 接收方代理使用POP3/IMAP从接收方邮件服务器获取邮件。
3. 域名系统（Domain Name System，DNS）
   1. 定义：一个由分层的DNS服务器实现的分布式数据库；一个使得主机能够查询分布式数据库的应用层协议。
   2. DNS服务器：
      1. 根DNS服务器：提供顶级域DNS服务器的IP地址。
      2. 顶级域（Top-Level Domain，TLD）DNS服务器：对于每个顶级域（如com、org、net、edu和gov）和所有国家的顶级域（如uk、fr、ca和jp），都有TLD服务器（或服务器集群）。TLD服务器提供了权威DNS服务器的IP地址。
      3. 权威DNS服务器：在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。一个组织机构的权威DNS服务器收藏了这些DNS记录。
      4. 本地DNS服务器：每个ISP（如一个居民区的ISP或一个机构的ISP）都有一台本地DNS服务器（也叫默认名字服务器）。
   3. 查询过程：
      1. 主机向它的本地DNS服务器发送一个DNS查询报文，该查询报文含有被转换的主机名；
      2. 本地DNS服务器将该报文转发到根DNS服务器，根DNS服务器根据被转换主机名的顶级域，返回负责该顶级域的TLD服务器的IP地址列表；
      3. 本地DNS服务器向这些TLD服务器之一发送查询报文，该TLD服务器用权威DNS服务器的IP地址进行响应；
      4. 本地DNS服务器向该权威DNS服务器发送查询报文，该权威DNS服务器用被转换的主机名的IP地址进行响应；
      5. 本地DNS服务器向主机返回查询结果。
   4. DNS缓存：为了改善时延性能并减少在因特网上到处传输的DNS报文数量，主机和DNS服务器广泛使用了缓存技术。它们能够将DNS记录缓存到本地存储器中，当收到的DNS查询中的主机名在缓存有对应记录时，就能够直接提供所要求的IP地址。

## 二、运输层

1. 用户数据报协议（UDP）

   ![UDP报文段结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220617084937.png)
2. 传输控制协议（TCP）
   1. 报文段结构

      ![TCP报文段结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220617090357.png)
   2. 可靠数据传输
      - 序号和确认号
         TCP把数据看成一个无结构的、有序的字节流。一个报文段的序号是其首字节的字节流编号，确认号是期望收到的下一字节的编号。
      - 定时器和超时重传
         1. 样本往返时间均值（EstimatedRTT)
            报文段的样本RTT（表示为SampleRTT）就是从某报文段被发出到对该报文段的确认被收到之间的时间量。TCP仅在某个时刻做一次SampleRTT测量，且仅为传输一次的报文段测量SampleRTT。
            $EstimatedRTT=(1-\alpha )\cdot EstimatedRTT + \alpha * SampleRTT$，在[RFC 6298]中给出的$\alpha$推荐值是$\alpha = 0.125$。
         2. 样本往返时间偏差（DevRTT）
            [RFC 6298]定义了RTT偏差DevRTT，用于估算SampleRTT一般会偏离EstimatedRTT的程度：$DevRTT=(1- \beta)\cdot DevRTT + \beta \cdot |SampleRTT-EstimatedRTT|$，$\beta$的推荐值为0.25。
         3. 超时间隔（TimeoutInterval）
            推荐的初始TimeoutInterval值为1秒，每次TCP重传时都会将下一次的超时间隔设为先前值的两倍。然而，只要收到报文段并更新EstimatedRTT，就使用公式$TimeoutInterval=EstimatedRTT+4 \cdot DevRTT$计算得到TimeoutInterval。
      - 累计确认（cumulative acknowledgment）和快速重传（fast retransmit）
         TCP只确认数据流中至第一个丢失字节为止的字节，所以被称为提供累计确认。
         当TCP接收方收到一个序号大于下一个所期望的、按序的报文段时，就说明有报文段丢失，这时它会对已经接收到的最后一个按序字节数据进行重复确认。如果TCP发送方接收到对相同数据的3个冗余ACK，就执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。
   3. 流量控制

      TCP通过让发送方维护一个称为接收窗口（receive window）的变量来提供流量控制，接收方用确认报文中的接收窗口给发送方一个指示——该接收方还有多少可用的缓存空间。
      当接收方的接收窗口为0时，发送方继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认，最终缓存开始清空，并且确认报文里将包含一个非0的rwnd值。
   4. 拥塞控制
      1. 慢启动
         当一条TCP连接开始时，拥塞窗口（congestion window，cwnd）的值通常初始置为一个最大报文长度（Maximum Segment Size，MSS），每过一个往返时间，拥塞窗口的值就翻倍。
      2. 拥塞避免
         当拥塞窗口的值大于等于慢启动阈值时，结束慢启动并且TCP转移到拥塞避免模式，每过一个往返时间，拥塞窗口的值增加一个最大报文长度。
      3. 快速恢复
         当检测到3个冗余ACK时，将慢启动阈值设置为当前拥塞窗口值的一半，同时拥塞窗口值设置为新慢启动阈值+3MSS。
   5. 连接管理
      1. 建立连接
         1. 客户端TCP向服务端TCP发送一个SYN报文段，该报文段首部的SYN标志位被置为1，同时随机选择一个初始序号，填入SYN报文段的序号字段中；
         2. 服务端TCP向客户端TCP发送一个允许连接的报文段，该报文段首部的SYN和ACK标志位被置为1，确认号为客户端初始序号+1，序号为服务端随机选择的初始序号。
         3. 客户端TCP对服务端的允许连接的报文段进行确认，该报文段首部的ACK标志位被置位1，确认号为服务端初始序号+1，序号为客户端初始序号+1。并且该报文段中可以包含应用层数据。
      2. 关闭连接
         1. 客户端TCP向服务端TCP发送一个FIN报文段，该报文段首部的FIN标志位被置位1；
         2. 服务端TCP向客户端TCP发送一个ACK报文段，对客户端的FIN报文段进行确认；
         3. 服务端TCP向客户端TCP发送一个FIN报文段，该报文段首部的FIN标志位被置位1；
         4. 客户端TCP向服务端TCP发送一个ACK报文段，对服务端的FIN报文段进行确认，然后客户端TCP进入TIME_WAIT状态，假定ACK报文段丢失，TIME_WAIT状态使客户端TCP重传最后的确认报文，同时TIME_WAIT状态还能避免之前超时的建立连接的报文段又到达服务端建立一条不需要的连接。
3. TCP与UDP的区别
   - 连接性
   TCP是面向连接的，开始数据传输前要经过3次握手建立连接，数据传输完毕后要经过4次挥手关闭连接，而UDP无需建立连接即可传输数据。因此，TCP需要在端系统中维护连接状态，而UDP不需要。
   - 可靠性
   TCP和UDP都使用校验和来处理比特差错的情况。TCP通过流量控制和拥塞控制遏制发送方的发送速度，通过字节编号解决报文失序和重复问题，通过确认和重传解决报文丢失问题。
   - 报文首部
   每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销。
   - 连接方数量
   TCP连接总是点对点的，因此只能实现单播。而UDP能实现单播、多播和广播。
   - 应用场景
   TCP适用于对传输效率要求低，对准确率要求高的应用场景，比如Web(HTTP)、文件传输(FTP)、电子邮件(SMTP)等。UDP适用于对传输效率要求高，但准确率要求低的应用场景，比如域名转换(DNS)、远程文件服务器(NFS)等。
4. 流行的因特网应用及其下面的运输协议：
   |   应用   |应用层协议|下面的传输协议|端口号|
   |:-------:|:--------:|:-----------:|:---:|
   | 电子邮件 |  SMTP  |  TCP  |      25     |
   |远程终端访问|Telnet|  TCP  |      23     |
   |  Web  |   HTTP   |  TCP  |      80     |
   | 文件传输 |  FTP   |  TCP  |     20、21  |
   |远程文件服务器|NFS|通常UDP|       2049    |
   |流式多媒体|通常专用|UDP或TCP|      -      |
   |因特网电话|通常专用|UDP或TCP|      -      |
   |网络管理|  SNMP  |通常UDP|    161、162   |
   |名字转换|  DNS  |通常UDP|        53      |
5. 安全套接字层（Secure Socket Layer，SSL）
   TCP的强化版本通常被称为安全套接字层（Secure Socket Layer，SSL），SSL版本3的一个稍加修改的版本被称为运输层安全性（Transport Layer Security，TLS），是一种旨在保护互联网通信安全的加密和身份验证协议。
   1. 作用：TLS协议实现的功能有三个主要组成部分：加密、认证和完整性。
      - 加密：隐藏从第三方传输的数据。
      - 身份验证：确保交换信息的各方是他们所声称的身份。
      - 完整性：验证数据未被伪造或篡改。
   2. 记录格式
      ![SSL记录格式](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220618125950.png)
   3. TLS握手
      ![TLS握手](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220919185656.png)
      - RSA密钥交换算法：
        1. "客户端问候(client hello)"消息：客户端通过向服务器发送"问候"消息来开始握手。该消息包含客户端支持的TLS版本，支持的密码套件，以及称为一个"客户端随机数(client random)"；
        2. "服务器问候(server hello)"消息：作为对client hello消息的回复，服务器发送一条消息，内含服务器的SSL证书、服务器选择的密码套件，以及一个"服务器随机数(server random)"；
        3. 身份验证：客户端使用颁发该证书的证书颁发机构验证服务器的SSL证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。
        4. 预主密钥：客户端发送一个使用服务器公钥加密的"预主密钥(premaster secret)"。
        5. 生成会话密钥：客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成会话密钥。双方应得到相同的结果。
        6. 客户端就绪：客户端发送一条"已完成"消息，该消息用会话密钥加密；
        7. 服务器就绪：服务器发送一条"已完成"消息，该消息用会话密钥加密。
      - Diffie-Hellman密钥交换算法：与RSA密钥交换算法不同，Diffie-Hellman算法使用指数计算得出相同的预主密钥。客户端不会直接发送预主密钥，服务器和客户端各自提供用于计算的DH参数，并且组合后在每一端产生不同的计算，但得出相等的结果，即预主密钥。
   4. TLS 1.3：TLS 1.3不支持RSA，也不支持易受攻击的其他密码套件和参数。它还缩短了TLS握手，使TLS 1.3握手更快更安全。
      1. 客户端问候：客户端发送客户端问候消息，内含协议版本、客户端随机数和密码套件列表。由于已从TLS 1.3中删除了对不安全密码套件的支持，因此可能的密码套件数量大大减少。客户端问候消息还包括将用于计算预主密钥的参数。大体上来说，客户端假设它知道服务器的首选密钥交换方法(由于简化的密码套件列表，它有可能知道)。这减少了握手的总长度——这是 TLS 1.3 握手与 TLS 1.0、1.1 和 1.2 握手之间的重要区别之一。
      2. 服务器生成主密钥：此时，服务器已经接收到客户端随机数以及客户端的参数和密码套件。它已经拥有服务器随机数，因为它可以自己生成。因此，服务器可以创建主密钥。
      3. 服务器问候和"完成"：服务器问候包括服务器的证书、数字签名、服务器随机数和选择的密码套件。因为它已经有了主密钥，所以它也发送了一个"完成"消息。
      4. 最后步骤和客户端"完成"：客户端验证签名和证书，生成主密钥，并发送"完成"消息。

      0-RTT模式用于会话恢复：TLS 1.3还支持一个更快的TLS握手版本，根本不需要任何往返，或客户端和服务器之间的来回通信。如果客户端和服务器之前已经相互连接(例如，如果用户之前访问过该网站)，它们可以各自从第一个会话中获取另一个共享密钥，称为"恢复主密钥"。在第一个会话期间，服务器还会向客户端发送称为会话票证的东西。客户端可以使用此共享密钥，在下一次会话的第一条消息中将加密数据连同该会话票证一起发送到服务器。然后TLS会在客户端和服务器之间恢复。
   5. 连接关闭
      在类型字段中指出该记录是否是用于终止该SSL会话的。

## 三、网络层

1. 网际协议（IP）
   1. IPv4
      1. 数据报格式
         ![IPv4数据报格式](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220618090929.png)
      2. 数据报分片
         当某路由器需要对一个数据报分片时，形成的每个数据报（即片）具有初始数据报的源地址、目的地址和标识号。最后一个片的标志比特被设为0，而所有其他片的标志比特被设为1。使用偏移字段指定该片应放在初始IP数据报的哪个位置。
      3. 编址
         每个IP地址长度为32比特，这些地址通常按所谓点分十进制记法（dotted-decimal notation）书写。
         1. 分类编址（classful addressing）：IP地址的网络部分被限制为长度为8、16或24比特。
         2. 无类别域间路由选择（Classless Interdomain Routing，CIDR）：IP地址的网络部分的长度没有限制。
         3. 获取IP地址：
            1. 获取一块地址：IP地址由因特网名字和编号分配机构（Internet Corporation for Assigned Names and Numbers，ICANN）管理，ICANN向区域性因特网注册机构分配地址，这些机构处理本区域内的地址分配/管理。
            2. 获取主机地址：动态主机配置协议（Dynamic Host Configuration，DHCP）
               1. DHCP服务器发现：DHCP客户生成包含DHCP发现报文（DHCP discover message）的IP数据报，其源IP地址为0.0.0.0，源端口号为68，目的IP地址为广播目的地址255.255.255.255，目的端口号为67；
               2. DHCP服务器提供：DHCP服务器收到一个DHCP发现报文时，用DHCP提供报文（DHCP offer message）向客户做出响应，其目的IP地址也为IP广播地址255.255.255.255；
               3. DHCP请求：客户从一个或多个服务器提供中选择一个，并向选中的服务器提供用DHCP请求报文（DHCP request message）进行响应，回显配置的参数；
               4. DHCP ACK：服务器用DHCP ACK报文（DHCP ACK message）对DHCP请求报文进行响应，证实所要求的的参数。
   2. 网络地址转换（Network Address Translation，NAT）
      从NAT路由器流向广域网的所有数据报都拥有一个源IP地址，从广域网到达NAT路由器的所有数据报都拥有同一个目的IP地址。NAT路由器维护了一张NAT转换表（NAT translation table），每个表项是广域网端口号和局域网内IP地址及端口号之间的映射
   3. IPv6
      1. 数据报格式
         ![IPv6数据报格式](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220618112259.png)
      2. IPv4和IPv6数据报的区别：
         - 分片/重新组装：IPv6不允许在中间路由器上进行分片与重新组装。
         - 首部检验和：IPv6数据报中去除了首部检验和。
         - 选项：选项字段不再是标准IP首部的一部分，可能出现在IPv6首部中由“下一个首部”指出的位置上。
      3. 从IPv4到IPv6的迁移
         建隧道：两个经由中间IPv4路由器互联的IPv6节点要使用IPv6数据报进行交互，将中间IPv4路由器的集合称为一个隧道，在隧道发送端的IPv6节点将整个IPv6数据报放到一个IPv4数据报的数据（有效载荷）字段中，该IPv4数据报的地址设为指向隧道接收端的IPv6节点。隧道中的中间IPv4路由器为该IPv4数据报提供路由，隧道接收端的IPv6节点最终收到该IPv4数据报，通过观察在IPv4数据报中的协议字段是41，确定该IPv4数据报含有一个IPv6数据报，从中取出IPv6数据报，然后再为该IPv6数据报提供路由。
2. 路由选择算法
   1. 因特网中自治系统内部的路由选择：开放最短路优先（OSPF）
      OSPF是一种链路状态协议，它使用泛洪链路状态信息和Dijkstra最低开销路径算法。使用OSPF，每台路由器构建了一幅关于整个自治系统的完整拓扑图，然后在本地运行Dijkstra的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。
   2. ISP之间的路由选择：边界网关协议（BGP）
      自治系统之间互相通告BGP路由信息，然后依次根据本地偏好值、AS-PATH长度、热土豆路由和BGP标识符来选择路由。
3. 软件定义网络（Software-Defined Networking，SDN）
   通用“匹配加动作”范式。
4. 因特网控制报文协议（Internet Control Message Protocol，ICMP）
   ICMP被主机和路由器用来彼此沟通网络层的信息，ICMP报文作为IP有效载荷承载的。ICMP报文有一个类型字段和一个编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节。
5. 简单网络管理协议（Simple Network Management Protocol，SNMP）
   SNMP是一个应用层协议，用于在管理服务器和代表管理服务器执行的代理之间传递网络管理控制和信息报文。SNMP协议数据单元（PDU）通常是作为UDP数据报的载荷进行传输的。

## 四、链路层和局域网

1. 载波侦听多路访问/碰撞检测（Carrier Sense Multiple Access with Collision Detection，CSMA/CD）
   1. 适配器从网络层获得一条数据报，准备链路层帧，并将其放入帧适配器缓存中；
   2. 如果适配器侦听到信道空闲，它开始传输帧，否则等待到没有信号能量时才开始传输帧；
   3. 在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在；
   4. 如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧，否则中止传输；
   5. 中止传输后，适配器采用二进制指数后退算法等待一个随机时间量，然后返回步骤2。
2. 地址解析协议（Address Resolution Protocol，ARP）
   1. 发送主机向它的适配器传递一个ARP查询分组，并且指示适配器应该用MAC广播地址来发送这个分组；
   2. 子网上的所有其他适配器都把在该帧中的ARP分组向上传递给ARP模块，与之匹配的一个给查询主机发送回一个带有所希望映射的响应ARP分组；
   3. 当要目的IP地址不在当前子网内时，应当使用当前子网的边界路由器的MAC地址作为目的地址。
3. 以太网
   ![以太网帧结构](https://cdn.jsdelivr.net/gh/n20u/PicBed/blogs/knowledge_combing/20220618192642.png)
